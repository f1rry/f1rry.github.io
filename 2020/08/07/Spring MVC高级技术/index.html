<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>F1rry's blog</title><meta name="description"><meta name="author" content="f1rry"><meta name="copyright" content="f1rry"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content=""><meta name="twitter:description"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content=""><meta property="og:url" content="http://yoursite.com/2020/08/07/Spring MVC高级技术/"><meta property="og:site_name" content="F1rry's blog"><meta property="og:description"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/08/07/Spring MVC高级技术/"><link rel="prev" title="" href="http://yoursite.com/2020/08/07/Spring MVC+ REST API/"><link rel="next" title="" href="http://yoursite.com/2020/08/07/AOP/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">F1rry's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Spring学习-Spirng-MVC的高级技术"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Spring学习 Spirng MVC的高级技术</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-MVC-配置的替代方案"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Spring MVC 配置的替代方案</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自定义-DispatcherServlet-配置"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">自定义 DispatcherServlet 配置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#添加其他的-Servlet-和-Filter"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">添加其他的 Servlet 和 Filter</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#在web-xml中声明DispatcherServlet"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">在web.xml中声明DispatcherServlet</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#处理multipart形式的数据"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">处理multipart形式的数据</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用Servlet-3-0-解析multipart请求-StandarServletMultipartResolver"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">使用Servlet 3.0 解析multipart请求(StandarServletMultipartResolver)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#配置MultipartResolver"><span class="toc_mobile_items-number">1.2.1.1.</span> <span class="toc_mobile_items-text">配置MultipartResolver</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#基于Java的配置"><span class="toc_mobile_items-number">1.2.1.1.1.</span> <span class="toc_mobile_items-text">基于Java的配置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#基于web-xml来配置"><span class="toc_mobile_items-number">1.2.1.1.2.</span> <span class="toc_mobile_items-text">基于web.xml来配置</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#处理multipart请求"><span class="toc_mobile_items-number">1.2.1.2.</span> <span class="toc_mobile_items-text">处理multipart请求</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#处理异常"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">处理异常</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自动将异常映射为HTTP状态码"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">自动将异常映射为HTTP状态码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#添加-ResponseStatus注解，将异常转换为HTTP状态码"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">添加@ResponseStatus注解，将异常转换为HTTP状态码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#编写异常处理的方法"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">编写异常处理的方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为控制器添加通知"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">为控制器添加通知</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#跨重定向请求传递数据"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">跨重定向请求传递数据</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用URL模板以及路径变量和-或查询参数的形式传递数据"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">使用URL模板以及路径变量和/或查询参数的形式传递数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用flash属性"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">使用flash属性</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring学习-Spirng-MVC的高级技术"><span class="toc-number">1.</span> <span class="toc-text">Spring学习 Spirng MVC的高级技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC-配置的替代方案"><span class="toc-number">1.1.</span> <span class="toc-text">Spring MVC 配置的替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义-DispatcherServlet-配置"><span class="toc-number">1.1.1.</span> <span class="toc-text">自定义 DispatcherServlet 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加其他的-Servlet-和-Filter"><span class="toc-number">1.1.2.</span> <span class="toc-text">添加其他的 Servlet 和 Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在web-xml中声明DispatcherServlet"><span class="toc-number">1.1.3.</span> <span class="toc-text">在web.xml中声明DispatcherServlet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理multipart形式的数据"><span class="toc-number">1.2.</span> <span class="toc-text">处理multipart形式的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Servlet-3-0-解析multipart请求-StandarServletMultipartResolver"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用Servlet 3.0 解析multipart请求(StandarServletMultipartResolver)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置MultipartResolver"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">配置MultipartResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基于Java的配置"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">基于Java的配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#基于web-xml来配置"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">基于web.xml来配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理multipart请求"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">处理multipart请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理异常"><span class="toc-number">1.3.</span> <span class="toc-text">处理异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自动将异常映射为HTTP状态码"><span class="toc-number">1.3.1.</span> <span class="toc-text">自动将异常映射为HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加-ResponseStatus注解，将异常转换为HTTP状态码"><span class="toc-number">1.3.2.</span> <span class="toc-text">添加@ResponseStatus注解，将异常转换为HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写异常处理的方法"><span class="toc-number">1.3.3.</span> <span class="toc-text">编写异常处理的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为控制器添加通知"><span class="toc-number">1.4.</span> <span class="toc-text">为控制器添加通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨重定向请求传递数据"><span class="toc-number">1.5.</span> <span class="toc-text">跨重定向请求传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用URL模板以及路径变量和-或查询参数的形式传递数据"><span class="toc-number">1.5.1.</span> <span class="toc-text">使用URL模板以及路径变量和/或查询参数的形式传递数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用flash属性"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用flash属性</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">无题</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-08-07<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-10-02</time><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 12 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Spring学习-Spirng-MVC的高级技术"><a href="#Spring学习-Spirng-MVC的高级技术" class="headerlink" title="Spring学习 Spirng MVC的高级技术"></a>Spring学习 Spirng MVC的高级技术</h1><p>前面讲了该如何通过拓展 AbstractAnnotationConfigDispatcherServletInitializer 配置DispatcherServlet、编写 Controller 从而快速搭建Spring MVC环境(使用JAVA配置)  </p>
<p>在本次学习中，主要介绍</p>
<ul>
<li>Spring MVC配置的替代方案  </li>
<li>处理文件上传</li>
<li>在控制器中处理异常 </li>
<li>使用flash属性  </li>
</ul>
<h2 id="Spring-MVC-配置的替代方案"><a href="#Spring-MVC-配置的替代方案" class="headerlink" title="Spring MVC 配置的替代方案"></a>Spring MVC 配置的替代方案</h2><p>用Java配置Spirng并不一定总能满足我么的要求。例如：</p>
<ol>
<li>除了 DispatcherServlet 以外，我们可能还需要额外的 Servlet 和 Fileter;</li>
<li>我们可能还需要对 DispatcherServlet 本身做一些额外的配置  </li>
<li>我们需要将应用部署到Servlet3.0之前的容器中，那么还需要将 DispatcherServlet 配置到传统的 web.xml 中  </li>
</ol>
<h3 id="自定义-DispatcherServlet-配置"><a href="#自定义-DispatcherServlet-配置" class="headerlink" title="自定义 DispatcherServlet 配置"></a>自定义 DispatcherServlet 配置</h3><p>除了基础篇所提到的可以被重载的三个方法外，AbstractAnnotationConfigDispatcherServletInitializer 中还有更多的方法可以被重载,以下举两个例子  </p>
<ul>
<li>customizeRegistration()</li>
<li>getServletFilters()</li>
</ul>
<p>以下是对于这两个重写的例子  </p>
<ol>
<li><p>customizeRegistration()<br>在 AbstractAnnotationConfigDispatcherServletInitializer 将DispatcherServlet 注册到 Servlet容器中之后，就会调用该方法，并将 Servlet 注册后得到的 Registration.Dynamic传递进来。通过重载 customizeRegistration() 方法 ，我们可以对 DispatcherServlet 进行额外配置。<br>例子如下 ，一下配置用于启用multipart请求，以处理multipart请求和文件上传 </p>
<pre><code>@Override
protected void customizeRegistration(Dynamic registration){
    registration.setMultiparConfig( new MultipartConfigElement(&quot;tmp/spitter/uploads&quot;));
}  
</code></pre></li>
<li><p>getServletFilters()<br>如果你知识注册Filter，并且该Filter只会映射到DispatcherServlet上的话，那么重载该方法就是一个快捷方式  </p>
<pre><code>@Override
protected Filter[] getServletFilters(){
    return new Filter[]{ new MyFilter()};
}  
</code></pre><p> 可以发现它是返回一个Filter数组，虽然我们这里只返回了一个Filter,但他可以返回多个，在这里没有必要声明它的映射路径，该方法返回的所有Filter都会映射到DispatcherServlet上。</p>
</li>
</ol>
<h3 id="添加其他的-Servlet-和-Filter"><a href="#添加其他的-Servlet-和-Filter" class="headerlink" title="添加其他的 Servlet 和 Filter"></a>添加其他的 Servlet 和 Filter</h3><p>你可能发现 AbstractAnnotationConfigDispatcherServletInitializer 只是注册了 DispatcherServlet 一个 Servlet 和 一个 Listener ，但如果你需要注册其他的Servlet 该怎么办呢？<br>根据之前学的基础篇，容器会在类路径中查找实现 javax.servlet.ServletContainerInitializer 接口的类，而 Spring 提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现了WebApplicationInitializer 接口的类并将配置的任务交给它们来完成。<br>而 AbstractAnnotationConfigDispatcherServletInitializer 就实现了这个 WebApplicationInitializer 接口，所以它会完成配置人物。  </p>
<p>同理推得，如果你想添加一个自己的Servlet、Listener、Filter，只需要创建实现了 WebApplicationInitializer 接口的类，以下是一个示例 </p>
<p>添加Servlet</p>
<pre><code>package com.myapp.config;


import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration.Dynamic;
import org.springframework.web.WebApplicationInitializer;
import com.myapp.MyServlet;

public class MyServletInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        //注册Servlet
        Dynamic myServlet = servletContext.addServlet(&quot;myServlet&quot;,MyServlet.class);

        //映射Servlet
        myServlet.addMapping(&quot;/custom/*&quot;);
    }
}
</code></pre><p>添加Filter  </p>
<pre><code>@Override
public void onStartup(ServletContext servletContext) throws ServletException {
    //注册Servlet
    javax.servlet.FilterRegistration.Dynamic filter = servletContext.addFilter(&quot;myFilter&quot;,MyFilter.class);

    //映射Servlet
    filter.addMappingForUrlPatterns(null,false,&quot;/custom/*&quot;);

}
</code></pre><p>如果只是注册Filter，并且该Filter只会映射到DispatcherServlet上的话，那么还有一种快捷方式。那就是重写 AbstractAnnotationConfigDispatcherServletInitializer 的 getServletFilters() 方法，上面已经有示例了  </p>
<h3 id="在web-xml中声明DispatcherServlet"><a href="#在web-xml中声明DispatcherServlet" class="headerlink" title="在web.xml中声明DispatcherServlet"></a>在web.xml中声明DispatcherServlet</h3><p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j13yalw4j30n90ie0xt.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j13yalw4j30n90ie0xt.jpg" class="lazyload" title=""></a>  </p>
<p>DispatcherServlet会根据Servlet的名字找到一个文件，并基于该文件加载应用上下文。该例的Servlet的名字是appServlet，因此 DispatcherServlet 会从”/WEB-INF/appServlet-context.xml”文件中加载其应用上下文。除此之外，<br>你还可以自己制定DispatcherServlet的配置文件所在，只需要添加 contextConfigLocation 初始化参数  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j1bkipo2j30il096ta6.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j1bkipo2j30il096ta6.jpg" class="lazyload" title=""></a>  </p>
<p>以上都是加载XML配置文件的web.xml的设置，如果需要加载基于java的配置文件的话，可以基于如下配置  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j1gcwn01j30k20p0wk3.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j1gcwn01j30k20p0wk3.jpg" class="lazyload" title=""></a>  </p>
<h2 id="处理multipart形式的数据"><a href="#处理multipart形式的数据" class="headerlink" title="处理multipart形式的数据"></a>处理multipart形式的数据</h2><p>DispatcherServlet 没有实现任何解析multipart请求数据的功能。它将该任务委托给Spring中 MultipartResolver 策略接口的实现，通过这个实现类来解析 multipart请求中的内容。  </p>
<p>从 Spring3.1 开始，Spring 内置了两个 MultipartResolver 的实现供我们选择：</p>
<ul>
<li>CommonsMultipartResolver:使用 Jakarta Commons FileUpload 解析 multipart 请求</li>
<li>StandarServletMultipartResolver: 依赖于 Servlet 3.0 对multipart请求的支持(始于 Spring 3.1)(推荐使用) </li>
</ul>
<p>由于 StandarServletMultipartResolver 不依赖于其他项目，所以一般来讲优先选它。  </p>
<h3 id="使用Servlet-3-0-解析multipart请求-StandarServletMultipartResolver"><a href="#使用Servlet-3-0-解析multipart请求-StandarServletMultipartResolver" class="headerlink" title="使用Servlet 3.0 解析multipart请求(StandarServletMultipartResolver)"></a>使用Servlet 3.0 解析multipart请求(StandarServletMultipartResolver)</h3><h4 id="配置MultipartResolver"><a href="#配置MultipartResolver" class="headerlink" title="配置MultipartResolver"></a>配置MultipartResolver</h4><h5 id="基于Java的配置"><a href="#基于Java的配置" class="headerlink" title="基于Java的配置"></a>基于Java的配置</h5><p>兼容Servlet 3.0的 StandarServletMultipartResolver 没有构造器参数，也没有要设置的属性。所以，在Spring应用上下文中，将其声明为bean就会非常简单，如下所示：</p>
<pre><code>@Bean
public MultipartResolver multipartResolver() throws IOException {
    return new StandarServletMultipartResolver();
}
</code></pre><p>声明为bean如此简单，可能会让人感觉到很奇怪，因为在这里它并没有做出例如指定临时目录、限制传输文件大小的配置。<br>但这样的声明是对的，因为关于multipart的配置是在Servlet中，而不是在Spring中。具体来讲，我们必须要在web.xml或 Servlet 初始化类中，将 multipart 的具体细节是作为 DispatcherServlet 的一部分的。<br>还记得在自定义 DispatcherServlet 配置时所重载的 customizeRegistration() 方法吗？我们就可以用它来为multipart提供具体细节(推荐使用这种方式),例子如下  </p>
<pre><code>@Override
protected void customizeRegistration(Dynamic registration){
    registration.setMultiparConfig( new MultipartConfigElement(&quot;tmp/spitter/uploads&quot;));
}  
</code></pre><p>还有一种，如果我们采用Servlet初始化类的方法来配置DispatcherServlet的话，该初始化类应该已经实现了 WebApplicationInitializer 接口，那我们可以在 Servlet registration 上调用 setMultipartConfig() 方法，传入一个MultipartConfig-Element实例<br>最基本的配置如下  </p>
<pre><code>package com.myapp.config;

import javax.servlet.MultipartConfigElement;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration.Dynamic;

import org.springframework.test.web.servlet.DispatcherServletCustomizer;
import org.springframework.web.WebApplicationInitializer;
import com.myapp.MyServlet;

public class MyServletInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        //注册Servlet
        DispatcherServletCustomizer ds = new DispatcherServlet();
        Dynamic registration = servletContext.addServlet(&quot;appServlet&quot;,ds);

        //映射Servlet
        registration.addMapping(&quot;/&quot;);
        registration.setMultipartConfig(
                new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;)
        );
    }
}
</code></pre><p>它们都设置了multipart的临时存放目录为 “/tmp/spittr/uploads”  </p>
<p>它们都使用了只有一个参数的MultipartConfigElement构造器，<br>但还存在其他的MultipartConfigElement构造器，它们所能接受的参数如下： </p>
<ul>
<li>上传文件的最大容量(以字节为单位)。默认是没有限制的。</li>
<li>整个multipart请求的最大容量(以字节为单位)。默认是没有限制的。</li>
<li>在上传的过程中，如果文件大小达到了一个指定最大容量(以字节为单位)，将会写入到临时文件路径中。默认值为0，也就是所有上传的文件都会写入到磁盘上。  </li>
</ul>
<p>例如，假设我们向限制文件的大小不超过2MB,整个请求不超过4MB,而且所有的文件都要写入到磁盘中。则代码应该如下  </p>
<pre><code>@Override
protected void customizeRegistration(Dynamic registration){
    registration.setMultiparConfig( new MultipartConfigElement(&quot;tmp/spitter/uploads&quot;,2097152,409304,0));
} 
</code></pre><h5 id="基于web-xml来配置"><a href="#基于web-xml来配置" class="headerlink" title="基于web.xml来配置"></a>基于web.xml来配置</h5><p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j5qi8yvkj30f307mgmv.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j5qi8yvkj30f307mgmv.jpg" class="lazyload" title=""></a>  </p>
<h4 id="处理multipart请求"><a href="#处理multipart请求" class="headerlink" title="处理multipart请求"></a>处理multipart请求</h4><p>Spring提供了MultipartFile接口，他为处理multipart数据提供了内容更为丰富的对象。如下展示了接口的概况。<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j5wy2oqkj30e8097gna.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j5wy2oqkj30e8097gna.jpg" class="lazyload" title=""></a>  </p>
<p>其中transferTo()方法能够帮助我们将上传的文件写入到文件系统中。  </p>
<p>那如何接受multipart类型的数据呢?那就是用@RequeestPart()注解了，其中传入里面的字符串为表单对应属性的key  </p>
<pre><code>@RequestMapping(value=&quot;/register&quot;,method=POST)
public String processRegistration{
    @RequestPart(&quot;profilePicture&quot;) MultipartFile profilePicture,
    @Valid Spitter spitter,
    Errors errors
} {

}  
</code></pre><p>如果你需要将应用部署到 Servlet3.0的容器中，那么会有 MultipartFile的一个替代方案。<br>Spring MVC也能接受javax.servlet.http.Part作为控制器方法的参数。<br>Part的接口概述如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7j6bfuur4j30g0093762.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7j6bfuur4j30g0093762.jpg" class="lazyload" title=""></a>  </p>
<p>如果使用Part来替换 MultipartFile 的话 ，那么processRegistration()方法签名将会变成如下的形式  </p>
<pre><code>@RequestMapping(value=&quot;/register&quot;,method=POST)
public String processRegistration{
    @RequestPart(&quot;profilePicture&quot;) Part profilePicture,
    @Valid Spitter spitter,
    Errors errors
} {

}  
</code></pre><p><strong><em>值得一提的是，如果在编写控制器方法的时候，通过 Part 参数的形式接受文件上传，那么就没不要配置 MultipartResolver 了。只有使用 MultipartFile 的时候，我们才需要 MultipartResolver</em></strong>  </p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>Spring 提供了多种方式将异常转换为响应:  </p>
<ul>
<li>特定的Spring 异常将会自动映射为指定的HTTP状态码  </li>
<li>异常上可以添加@ResponseStatus注解，从而将其映射为某一个HTTP状态码</li>
<li>在方法上可以添加@ExceptionHandler注解，使其用来处理异常  </li>
</ul>
<h3 id="自动将异常映射为HTTP状态码"><a href="#自动将异常映射为HTTP状态码" class="headerlink" title="自动将异常映射为HTTP状态码"></a>自动将异常映射为HTTP状态码</h3><p>在默认情况下，Spring会将自身的一些异常自动转换为何时的状态码<br>以下是这些映射关系  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7jrlxx0f9j30mx0oon1a.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7jrlxx0f9j30mx0oon1a.jpg" class="lazyload" title=""></a>  </p>
<p>这些异常一般会由 Spirng 自身抛出，作为 DispatcherServlet 处理过程中或执行检验时出现问题的结果。例如，如果 DispatcherServlet 无法找到适合处理请求的控制器方法，你们将会抛出 NoSuchRequestHandlingMethodException 异常，最终的结果就是产生 404 状态码的响应。  </p>
<h3 id="添加-ResponseStatus注解，将异常转换为HTTP状态码"><a href="#添加-ResponseStatus注解，将异常转换为HTTP状态码" class="headerlink" title="添加@ResponseStatus注解，将异常转换为HTTP状态码"></a>添加@ResponseStatus注解，将异常转换为HTTP状态码</h3><p>如果出现任何没有映射的异常，响应都会带有 500 状态码，<br>但是，我们可以通过映射自定义异常，对这种默认行为进行变更。<br>例如我们先自定义一个 SpittleNotFoundException 异常  </p>
<pre><code>package spitter.web;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(value=HttpStatus.NOT_FOUND,reason=&quot;Spittle Not Found&quot;)
public class SpittleNotFoundException extends RuntimeException {
}
</code></pre><p>然后使用它  </p>
<pre><code>@RequestMapping(Value=&quot;/{spittleId}&quot;,method=RequestMethod.GET)
public String spittle{
    @PathVariable(&quot;spittleId&quot;) long spittleId
    Model model
}{
    Spittle spittle = spittleRepository.findOne(spittleId);
    if (spittle == null){
        throw new SpittleNotFoundException();
    }
    model.addAttribute(spittle);
    return &quot;spittle&quot;;
}
</code></pre><h3 id="编写异常处理的方法"><a href="#编写异常处理的方法" class="headerlink" title="编写异常处理的方法"></a>编写异常处理的方法</h3><p>如果我们想在响应中不仅要包括状态码，还要包含所产生的错误，我们就需要编写异常处理的方法了，而不是简单的将异常映射为状态码。这里有两种方案</p>
<ul>
<li>运用try…catch结构直接将处理异常的方法写在控制器内  </li>
<li>将异常处理与控制器剥离，使它适用于同一个控制器的所有方法或所有控制器，而不是绑定与特定的控制器中  </li>
</ul>
<p>这里我们主要介绍第二种方法  </p>
<ul>
<li><p>适用于同一个控制器的所有方法<br>  我们为controller添加一个新方法，它会处理这个Controller中所有方法所抛出的DuplicateSpittleException的情况</p>
<pre><code>@ExceptionHandler(DuplicaticateSpittleException.class)
public String handleDuplicateSpittle(){
    return &quot;error/duplicate&quot;;
}
</code></pre></li>
<li><p>适用于所有控制器的所有方法<br>  从Spring3.2开始，我们只需将其定义到控制器通知类中即可 </p>
</li>
</ul>
<h2 id="为控制器添加通知"><a href="#为控制器添加通知" class="headerlink" title="为控制器添加通知"></a>为控制器添加通知</h2><p>如果控制器类的特定切面能够运用到整个应用程序的所有控制器中，你们这将会遍历很多。<br>控制器通知(controller advice)是任意带有@ControllerAdvice 注解的类<br>这个类会包含一个或多个如下类型的方法:  </p>
<ul>
<li>@ExceptionHandler 注解标注的方法;</li>
<li>@InitBinder 注解标注的方法;</li>
<li>@ModelAttribute 注解标注的方法  </li>
</ul>
<p>@ControllerAdvice注解本身已经使用了@Component，因此它所标注的类会被组件自动扫描获取到。<br>例如将所有的@ExceptionHandler方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理  </p>
<pre><code>package spitter.web;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class AppWideExceptionHandler {
    @ExceptionHandler(DuplicateSpittleException.class)
    public String duplicateSpittleHandler() {
        return &quot;error/duplicate&quot;;
    }
}
</code></pre><p>现在，不管这个方法位于哪个控制器中，只要抛出了DuplicateSpittleException,都会调用这个duplicateSpittleHandler()方法来处理异常。  </p>
<h2 id="跨重定向请求传递数据"><a href="#跨重定向请求传递数据" class="headerlink" title="跨重定向请求传递数据"></a>跨重定向请求传递数据</h2><p>由前面的学习可知，我们可以通过 </p>
<pre><code>return &quot;redict:/home&quot;
</code></pre><p>语句来进行重定向。<br>对于重定向需要明确的是:</p>
<ul>
<li>当一个处理器方法完成之后，该方法所指定的模型数据将会复制到请求中，并作为请求中的属性，请求会转发到仕途上进行渲染。因为控制器方法和视图所处理的是同一个请求，所以在转发的过程中，请求属性能够得以保存。  </li>
<li>当控制器的结果是重定向的话，原始的请求就结束了，并且会发起一个新的GET请求。原始请求中所带有的模型数据也能随着请求一起消亡。在新的请求属性中，没有任何的模型数据。  </li>
</ul>
<p>所以我们需要想办法赖在重定向请求中传递数据  </p>
<ul>
<li>使用URL模板以及路径变量和/或查询参数的形式传递数据;</li>
<li>通过flash属性发送数据</li>
</ul>
<h3 id="使用URL模板以及路径变量和-或查询参数的形式传递数据"><a href="#使用URL模板以及路径变量和-或查询参数的形式传递数据" class="headerlink" title="使用URL模板以及路径变量和/或查询参数的形式传递数据"></a>使用URL模板以及路径变量和/或查询参数的形式传递数据</h3><ul>
<li><p>路径变量和查询参数传递(不安全)  </p>
<pre><code>return &quot;redirect:/spitter/{username}&quot;;
</code></pre></li>
<li><p>使用URL模板(在连接到String前，会将username中所有的不安全字符都进行转义)  </p>
<pre><code>@RequestMapping(value=&quot;/register&quot;,method = POST)
public String processRegistration(Spitter spitter,Model model){

    spitterRepository.save(spitter);
    model.addAttribute(&quot;username&quot;,spitter.getUsername());
    return &quot;redirect:/spitter/{username}&quot;;
}
</code></pre><p>  也可以把模板运用在查询参数  </p>
<pre><code>@RequestMapping(value=&quot;/register&quot;,method = POST)
public String processRegistration(Spitter spitter,Model model){

    spitterRepository.save(spitter);
    model.addAttribute(&quot;username&quot;,spitter.getUsername());
    model.addAttribute(&quot;spittleId&quot;,spitter.getId());
    return &quot;redirect:/spitter/{username}&quot;;
}
</code></pre><p>  因为模型中的spitterId属性没有匹配重定向URL中的任何占位符，所以它会自动以查询参数的形式附加到重定向URL上。</p>
</li>
</ul>
<h3 id="使用flash属性"><a href="#使用flash属性" class="headerlink" title="使用flash属性"></a>使用flash属性</h3><p>如果我们要传送复杂的数据，例如对象，那就需要用到flash属性了。由于模型数据不会在重定向中保留，但我们可以将模型数据存在会话中，然后在重定向的方法中取出会话中的模型数据并从会话中删除它。而flash属性就提供了这么一种功能。<br>Spring提供了将数据发送为flash属性的功能。按照定义 ，flash属性会一直携带这些数据直到下一次请求，然后才会消失。<br>flash属性 原理如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7k1h78msyj30kv0bl773.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7k1h78msyj30kv0bl773.jpg" class="lazyload" title=""></a>  </p>
<p>Spring 提供了通过RedirectAttributes 设置flash属性的方法,这是Spring 3.1 引入的Model的一个子接口。RedirectAttributes 提供了Model的所有功能，除此之外，还有几个方法是用来设置flash属性的。  </p>
<p>具体来讲， RedirectAttributes 提供了一组 addFlashAttribute() 方法来添加flash属性。  </p>
<p>以下是例子，注意其传入的参数的类型为RedirectAttributes 以及使用了addFlashAttribute()方法。  </p>
<pre><code>@RequestMapping(value=&quot;/register&quot;,method = POST)
public String processRegistration(Spitter spitter,RedirectAttributes model){

    spitterRepository.save(spitter);
    model.addAttribute(&quot;username&quot;,spitter.getUsername());
    model.addFlashAttribute(&quot;spitter&quot;,spitter);
    return &quot;redirect:/spitter/{username}&quot;;
}
</code></pre></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">f1rry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/07/Spring MVC高级技术/">http://yoursite.com/2020/08/07/Spring MVC高级技术/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">F1rry's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/07/Spring MVC+ REST API/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span></span></div></a></div><div class="next-post pull_right"><a href="/2020/08/07/AOP/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span></span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By f1rry</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>