<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>排序算法 | F1rry's blog</title><meta name="description" content="排序算法"><meta name="keywords" content="JAVA,数据结构"><meta name="author" content="f1rry"><meta name="copyright" content="f1rry"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="排序算法"><meta name="twitter:description" content="排序算法"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="排序算法"><meta property="og:url" content="http://yoursite.com/2020/02/07/排序/"><meta property="og:site_name" content="F1rry's blog"><meta property="og:description" content="排序算法"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/07/排序/"><link rel="prev" title="图论算法" href="http://yoursite.com/2020/02/10/图论算法/"><link rel="next" title="JAVA 散列" href="http://yoursite.com/2020/02/03/java 散列/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">F1rry's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一些下界"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一些下界</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#插入排序"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">插入排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#希尔排序"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">希尔排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#重要性质"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">重要性质</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-1"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#希尔排序小结"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">希尔排序小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#堆排序"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">堆排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-2"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现-1"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#堆排序小结"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">堆排序小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#归并排序"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">归并排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-3"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现-2"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#归并排序小结"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">归并排序小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#快速排序"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">快速排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-4"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#选择问题的线性期望时间算法——快速选择"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">选择问题的线性期望时间算法——快速选择</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现-3"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#快速排序小结"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">快速排序小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#桶排序"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">桶排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-5"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#桶排序小结"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">桶排序小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#外部排序"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">外部排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现思路-6"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">实现思路</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一些排序算法运行时间的比较"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">一些排序算法运行时间的比较</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一些下界"><span class="toc-number">1.</span> <span class="toc-text">一些下界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-number">2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路"><span class="toc-number">2.1.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序"><span class="toc-number">3.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重要性质"><span class="toc-number">3.1.</span> <span class="toc-text">重要性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-1"><span class="toc-number">3.2.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-number">3.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序小结"><span class="toc-number">3.4.</span> <span class="toc-text">希尔排序小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序"><span class="toc-number">4.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-2"><span class="toc-number">4.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-1"><span class="toc-number">4.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序小结"><span class="toc-number">4.3.</span> <span class="toc-text">堆排序小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">5.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-3"><span class="toc-number">5.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-number">5.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序小结"><span class="toc-number">5.3.</span> <span class="toc-text">归并排序小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序"><span class="toc-number">6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-4"><span class="toc-number">6.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择问题的线性期望时间算法——快速选择"><span class="toc-number">6.2.</span> <span class="toc-text">选择问题的线性期望时间算法——快速选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-number">6.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序小结"><span class="toc-number">6.4.</span> <span class="toc-text">快速排序小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排序"><span class="toc-number">7.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-5"><span class="toc-number">7.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序小结"><span class="toc-number">7.2.</span> <span class="toc-text">桶排序小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部排序"><span class="toc-number">8.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现思路-6"><span class="toc-number">8.1.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些排序算法运行时间的比较"><span class="toc-number">9.</span> <span class="toc-text">一些排序算法运行时间的比较</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">排序算法</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-07<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-08-07</time><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 23 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="一些下界"><a href="#一些下界" class="headerlink" title="一些下界"></a>一些下界</h2><ul>
<li><p>简单排序算法的下界<br>所谓的简单排序指的是指通过交换相邻元素进行排序的算法。<br>由于 $N$ 个互异数的数组的平均逆序数是 $N*(N-1)/4$<br>所以一个简单排序算法平均都需要 $\Omega(N^2)$的运行时间。<br>因此为了使排序算法以亚二次时间运行，必须执行一些比较，特别是对相距较远的元素进行比较  </p>
</li>
<li><p>排序算法的一般下界<br>所谓排序算法的一般下界，指的是 只用到比较的任意排序算法<br>它们的最坏情况下都需要 $\left\lceil \log N! \right\rceil$（即 $\Omega(N\log N)$） 次比较，因此归并排序和堆排序在一个常数因子范围内是最优的。 并且平均都需要 $\log N!$ 次比较</p>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序时最为基础的排序算法，它以 $O(N^2)$ 的运行时间</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>实现思路如下  </p>
<ol>
<li>当已排序的序列大小为0时，将插入的待排序的元素放入序列首部  </li>
<li>当已排序的序列大小不为0时，将插入的待排序的元素与已排序序列中的元素从第一个位置开始逐一比较，移过那些比待排序元素小的元素，停留在第一个比待排序元素大的元素的位置上，将后面的元素右移，然后在该位置插入待排序的元素。</li>
<li>重复步骤二，知道待排序的序列大小变为0,。<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h3>一个$h_k$ 排序的文件（然后将是$h_{k-1}排序的$）将保持它的$h_k$排序性。<br>如果没有这个重要性质，那么前面各趟的排序结果将会被后面的排序所打乱，从而使得该算法就没什么价值<h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3>希尔算法使用一个增量序列 $h_1,h_2,h_3…h_k$($h_1=1$)来实现排序。而增量序列的选择将对运行时间有着决定性的作用。<br>在使用增量 $h_k$ 的一趟排序后，对于每一个$i$我们都有 $a[i]&lt;=a[i+h_k]$，所以相距 $h_k$的元素都被排序。此时称文件是 $h_k$排序的。<br>在使用增量 $h_k$ 排序完后，我们再使用使用增量 $h_{k-1}$ 进行排序，直到 $h_1$ 为止。  </li>
</ol>
<p>一趟 $h_k$ 排序的一般做法是，对于$h_k,h_k+1,h_k+2,…,N$中的每一个位置$i$，把其上的元素放在$i,i-h_k,i-2<em>h_k,…,i-n</em>h_k$ 中的正确的位置   </p>
<p>下图可直观感受下希尔排序  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbii3dw332j30it05974j.jpg" data-fancybox="group" data-caption="QQ截图20200202235545.jpg" class="fancybox"><img alt="QQ截图20200202235545.jpg" title="QQ截图20200202235545.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbii3dw332j30it05974j.jpg" class="lazyload"></a>  </p>
<p>下面是几种常见的增量序列的选择</p>
<ul>
<li><p>Shell 增量序列（希尔增量）<br>$h_t = \left\lfloor N/2\right\rfloor , h_k =\left\lfloor h_{k+1}/2 \right\rfloor$(流行但不好)<br>使用 shell 增量序列的希尔排序最坏情形运行时间为$\Theta(N^2)$  </p>
</li>
<li><p>Hibbard 增量序列<br>$h_i = 2^i-1$<br>使用 Hibbard 增量的希尔排序最坏情形运行时间为$\Theta(N^{3/2})$   </p>
</li>
<li><p>Sedgewick 增量序列<br>该增量序列中的项或者以$h_i = 9 <em> 4^i - 9 </em> 2^i + 1$的形式，或者以 $h_i = 4^i - 3 * 2^i + 1$的形式，其中最好的序列是 ${1,5,19,41,109…}$<br>使用 Sedgewick 增量的希尔排序最坏情形运行时间为$O(N^{4/3})$</p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] a) &#123;</span><br><span class="line">    int index = (int) Math.floor(Math.log(a.length/2 + 1)/Math.log(2)) + 1;</span><br><span class="line">    int gap;</span><br><span class="line">    int temp;</span><br><span class="line">    int j;</span><br><span class="line">    for (int i = index; i &gt; 0; i--) &#123;</span><br><span class="line">        gap = (int) Math.pow(2,i) - 1;</span><br><span class="line">        for (int pos = gap; pos &lt; a.length; pos++) &#123;</span><br><span class="line">            temp = a[pos];</span><br><span class="line">            for (j = pos; j &gt;= gap &amp;&amp; temp &lt;= a[j-gap] ; j-=gap) &#123;</span><br><span class="line">                a[j] = a[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="希尔排序小结"><a href="#希尔排序小结" class="headerlink" title="希尔排序小结"></a>希尔排序小结</h3><p>希尔排序的性能在实践中是完全可以接受的，即使是对于数以万计的 N 任是如此。编程的简单特点使得它成为对适度地大量的输入数据经常选用的算法。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h3><p>这里以让一个乱序的序列变成一个递减序列为例  </p>
<ol>
<li><p>用乱序的序列中的元素构造一个最小堆(二叉堆实现)<br> 在这个阶段需要花费 $O(N)$ 来构造最小堆。<br> 在这一阶段最多用到 $2N$ 次比较</p>
</li>
<li><p>使用 deleteMin 方法删除最小堆的根节点<br> 这里的 deleteMin 方法与普通堆的 deleteMin 方法有所不同。堆排序中的 deleteMin 方法会将根元素移动到堆的最末尾，然后让堆缩小1。<br> 而这么做的原因在于解决堆排序的空间问题，即不再需要使用一个附加的数组来存储排序好的序列了<br> 在这个阶段每一次 deleteMin 操作需要花费 $O(\log N)$，总共需要 N 次操作，所以总共需要花费 $O(N\log N)$<br> 在这一阶段，第 $i$ 次 deleteMin 操作最多用到 $2\left\lfloor \log i\right\rfloor$ 次比较，总共需要 N 次操作，所以总数最多为 $2N\left\lfloor \log N\right\rfloor - O(N)$ 次比较。</p>
</li>
<li><p>当堆的大小减到0的时候，排序结束，返回数组。<br> 将前两个步骤的比较次数和运行时间相加<br> 比较次数最多为 $2N+2N\left\lfloor \log N\right\rfloor - O(N)$，平均比较次数为$2N\left\lfloor \log N\right\rfloor - O(N\log\log N)$<br> 运行时间为 $O(N+N\log N) = O(N\log N)$  </p>
</li>
</ol>
<p>示例图如下 </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7um4lqj30mg071mxc.jpg" data-fancybox="group" data-caption="QQ截图20200204221258.jpg" class="fancybox"><img alt="QQ截图20200204221258.jpg" title="QQ截图20200204221258.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7um4lqj30mg071mxc.jpg" class="lazyload"></a>  </p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    </span><br><span class="line">    private int[] heap;</span><br><span class="line">    private int currentSize;</span><br><span class="line">    </span><br><span class="line">    public void upFilter(int pos) &#123;</span><br><span class="line">        int temp = heap[pos];</span><br><span class="line">        while ((pos &gt; 0) &amp;&amp; (temp &lt; heap[(pos+1)/2-1])) &#123;</span><br><span class="line">            heap[pos] = heap[(pos+1)/2-1];</span><br><span class="line">            pos = ( pos + 1 ) / 2 - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[pos] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void downFilter(int pos) &#123;</span><br><span class="line">        int temp = heap[pos];</span><br><span class="line">        int child = (pos + 1) * 2 - 1;</span><br><span class="line">        while (child &lt; currentSize) &#123;</span><br><span class="line">            if ((child != currentSize - 1) &amp;&amp; (heap[child + 1] &lt; heap[child])) &#123;</span><br><span class="line">                child += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (heap[child] &lt; temp) &#123;</span><br><span class="line">                heap[pos] = heap[child];</span><br><span class="line">                pos = child;</span><br><span class="line">                child = (pos + 1) * 2 - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[pos] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void insert(int ele) &#123;</span><br><span class="line">        currentSize += 1;</span><br><span class="line">        if (currentSize &gt; heap.length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[currentSize - 1] = ele;</span><br><span class="line">        upFilter(currentSize - 1);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteMin() &#123;</span><br><span class="line">        int temp = heap[0];</span><br><span class="line">        heap[0] = heap[currentSize - 1];</span><br><span class="line">        currentSize -= 1;</span><br><span class="line">        downFilter(0);</span><br><span class="line">        heap[currentSize] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void buildHeap(int[] a) &#123;</span><br><span class="line">        heap = new int[a.length];</span><br><span class="line">        currentSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void heapSort(int[] a) &#123;</span><br><span class="line">        buildHeap(a);</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            deleteMin();</span><br><span class="line">        &#125;</span><br><span class="line">        displayArray(heap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayArray(int[] a) &#123;</span><br><span class="line">        for (int item : a) &#123;</span><br><span class="line">            System.out.print(item+&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HeapSort heapSort = new HeapSort();</span><br><span class="line">        int[] a = &#123;5,2,8,3,1,2,9,20,26,22,17&#125;;</span><br><span class="line">        heapSort.displayArray(a);</span><br><span class="line">        heapSort.heapSort(a);</span><br><span class="line">        heapSort.displayArray(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="堆排序小结"><a href="#堆排序小结" class="headerlink" title="堆排序小结"></a>堆排序小结</h3><ul>
<li><p>优点</p>
<ul>
<li>堆排序以 $O(N\log(N))$ 的运行时间来排序</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>该算法的主要问题在于他使用了一个附加的数组。因此，存储需要增加一倍。而回避这一问题的聪明方法是在每一次 deleteMin 的时候，堆缩小1。因此位于堆中的最后一个单元可以用来存放刚刚用 deleteMin 删去的元素。</p>
</li>
<li><p>该算法的还有一个问题就是排序时，元素之间的比较次数很多。<br>而 java 对象元素之间的比较的开销是比较大的。 </p>
</li>
</ul>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>虽然说堆排序已经将运行时间降低为 $O(N\log N)$,但他的一次排序中比较次数过多，使用java 编程时比较所产生的的开销会比较大，所以我们引入了归并排序，它只需要$O(N)$次比较,但也只需要 $O(N\log N)$ 的运行时间。</p>
<h3 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h3><p>归并排序的整体思想是”分治”。<br>基本的归并算法是取两个输入数组，一个输出数组，三个变量attr,bttr,cttr分别用来记录这三个数组中的位置信息。<br>一次归并的步骤如下：  </p>
<ol>
<li>两个输入数组a,b 从attr,bttr从0开始，比较$a[attr],b[bttr]$，将小的元素放入数组c，然后使attr,cttr 或者 bttr,cttr 加一。重复如上操作，直到两个输入数组中的一个数组全部被放入输出数组中  </li>
<li>将另一个输入数组的剩余部分放入到输出数组</li>
</ol>
<p>而归并排序的思路为：</p>
<ol>
<li>先“分”：将输入的序列分为对半分为两部分，对于每部分继续对半分直到不能分为止</li>
<li>后“治”：运用上面的归并步骤归并分好的两部分。  </li>
</ol>
<p>示例图如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7ujbqaj30ho09u0t9.jpg" data-fancybox="group" data-caption="QQ截图20200204221237.jpg" class="fancybox"><img alt="QQ截图20200204221237.jpg" title="QQ截图20200204221237.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7ujbqaj30ho09u0t9.jpg" class="lazyload"></a>  </p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package sort;</span><br><span class="line"></span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int[] a) &#123;</span><br><span class="line">        int[] temp = new int[a.length];</span><br><span class="line">        merge(a, temp,0,a.length/2);</span><br><span class="line">        merge(a, temp,a.length/2 + 1, a.length - 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] a, int[] temp, int left, int right) &#123;</span><br><span class="line">        int center = (left + right) / 2;</span><br><span class="line">        if (left &lt; center) &#123;</span><br><span class="line">            merge(a, temp, left, center);</span><br><span class="line">            merge(a, temp, center + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = left;</span><br><span class="line">        int j = left;</span><br><span class="line">        int k = center + 1;</span><br><span class="line">        while (i &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">            if ( j &gt; center) &#123;</span><br><span class="line">                while ( k &lt;= right) &#123;</span><br><span class="line">                    temp[i++] = a[k++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ( k &gt; right) &#123;</span><br><span class="line">                while ( j &lt;= center) &#123;</span><br><span class="line">                    temp[i++] = a[j++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (j &lt;= center &amp;&amp; a[j] &lt;= a[k]) &#123;</span><br><span class="line">                temp[i++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &lt;= right &amp;&amp; a[k] &lt; a[j]) &#123;</span><br><span class="line">                temp[i++] = a[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int l = left; l &lt;= right; l++) &#123;</span><br><span class="line">            a[l] = temp[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayArray(int[] a) &#123;</span><br><span class="line">        for (int item : a) &#123;</span><br><span class="line">            System.out.print(item+&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MergeSort mergeSort = new MergeSort();</span><br><span class="line">        int[] a = &#123;5,2,8,3,1,2,9,20,26,22,17&#125;;</span><br><span class="line">        mergeSort.displayArray(a);</span><br><span class="line">        mergeSort.mergeSort(a);</span><br><span class="line">        mergeSort.displayArray(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="归并排序小结"><a href="#归并排序小结" class="headerlink" title="归并排序小结"></a>归并排序小结</h3><p>虽然归并排序的运行时间是 $O(N\log N)$ ，但是它有一个明显的问题，即合并两个已排序的表用到线性附加内存。在整个算法中还要花费将数据拷贝到临时数组再拷贝回来这样一些附加操作，它明显减慢了排序的速度。这种拷贝可以通过在递归的那些交替层次上审慎的交换 a 和 tempArray 的角色得以避免。<br>与其他的$O(N\log N)$排序算法比较，归并排序的运行时间严重依赖于比较元素和在数组中元素移动的相对开销。这与具体的编程语言相关，在 java 中由于元素移动是引用的赋值，所以元素移动是比较容易的，但是当执行一次泛型比较时(使用comparator)进行一次元素比较，开销可能是昂贵的。<br>事实上，它就是Java标准类库中泛型排序所使用的算法</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h3><p>快速排序也是一种分治的递归算法<br>一个quickSort其基本步骤如下</p>
<ol>
<li>如果 $S$ 中元素个数是 0 或 1 ，则返回。</li>
<li>取 $S$ 中任一元素 $v$, 称之为枢纽元</li>
<li>将 $S - {v}$($S$中其余元素)划分为两个不相交的集合，$S_1 = {x\in S - {v}\space |\space x\leq v}$ 和 $S_2 = {x\in S - {v}\space |\space x\geq v}$  </li>
<li>返回${quickSort(S_1),v,quickSort(S_2)}$   </li>
</ol>
<p>而快速排序需要注意以下几点</p>
<ul>
<li><p>选取枢纽元<br>  枢纽元的选取将决定该算法的好坏，一个较好的枢纽元，应该是能将待排序的序列分成两个大小近似相等的部分。<br>  下面将介绍三种选取枢纽元的方法</p>
<ul>
<li><p>错误的方法<br>  直接选取序列中的第一个元素作为枢纽元，这时，如果输入是预排序的或者是反序的，那么这样的枢纽元将产生一个劣质的分割，因为所有的元素不是被划入$S_1$就是被划入$S_2$。更糟糕的是这种划分将会出现在每个递归调用中。因此这时的快速排序的运行时间将变为 $O(N^2)$  </p>
</li>
<li><p>安全但开销较大的方法<br>  通过随机数生成器随机选取枢纽元，这是一个非常安全的策略，但是随机数的生成一般开销很大，根本减少不了算法的其余部分的平均运行时间  </p>
</li>
<li><p>推荐的方法  三数中值分割法<br>  该方法的一般做法是选取待排序序列的第一个元素、最后一个元素以及最中间的元素，对这三个数排序选择他们的中值作为枢纽元。这种方法既避免了方法一中输入序列中出现预先排序的序列的情况，也避免了方法二中生成随机数开销过大的问题，所以是个推荐的方法  </p>
</li>
</ul>
</li>
<li><p>分割策略<br>  分割是一种容易出错或低效的操作，但使用一种已知方法是安全的。<br>  下面是一个已被证明能给出好结果的分割策略，其步骤如下  </p>
<ol>
<li><p>将枢纽元与最后的元素交换使得枢纽元离开要被分割的数据段，而$i$从第一个元素开始，而$j$从倒数第二个元素开始， </p>
</li>
<li><p>当$i$在$j$左边时，我们将$i$右移，移过那些小于枢纽元的元素，并将$j$左移，移过那些大于枢纽元的元素。</p>
</li>
<li><p>当 $i$ 和 $j$ 都停止时，$i$指向一个“大元素”，$j$指向一个“小元素”，互换$i$和$j$所指向的两个元素，重复第二步的过程。直到 $i$ 在 $j$ 的右边，执行第四步  </p>
</li>
<li><p>互换 $i$ 指向的元素和枢纽元  </p>
<p>而这个分割策略还需要思考一个问题，那就是当序列中有元素与枢纽元相等时，是否应该移过该元素  </p>
</li>
</ol>
<ul>
<li><p>移过（不推荐）<br>  移过虽然能减少交换次数，但是由于枢纽元要与$i$最后所抵达的位置中的元素互换，这样会产生两个非常不均衡的子数组。<br>  例如当数组元素都相等时，我们会首先让$i$ 右移，移过那些小于等于枢纽元的元素，直到与$j$交错，因为在这个例子中所有元素都相等，那么$i$会一直移到倒数第二个元素，这样会使得 $S_1$ 有 $N-1$ 个元素 而 $S_2$ 只有 $1$ 个元素，相当于没有分割，其运行时间将会变为 $O(N^2)$，所以并不推荐。</p>
</li>
<li><p>不移过（推荐）<br>  不移过虽然会使得交换次数变多，但是其正面效果确是 $i$ 和 $j$ 将在中间交错，即会产生两个较为均衡的子数组，所以是个推荐的做法  </p>
<p>示例图如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7ujy3wj30fm0ogaal.jpg" data-fancybox="group" data-caption="QQ截图20200204221200.jpg" class="fancybox"><img alt="QQ截图20200204221200.jpg" title="QQ截图20200204221200.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7ujy3wj30fm0ogaal.jpg" class="lazyload"></a></p>
</li>
</ul>
</li>
<li><p>小数组<br>  对于很小的数组($N \leq 20$) 快速排序不如插入排序。不仅如此，因为快速排序是递归的(即在递归过程中会将一个大数组分解成为一个个小数组)，所以这样的情形会经常发生。<br>  通常的解决方法是对于小数组，采取诸如插入排序这样的对小数组有效的排序算法。使用这种策略实际上可以节省 $15%$ 的运行时间。<br>  一种好的截止范围是 $N=10$，即当 $N\leq10$时，选择插入算法，当 $N &gt; 10$ 时采取快速排序</p>
</li>
</ul>
<p>除了上述几点注意点外，还可以做一些优化，即在用三数中值法时，可以将最小元素放在第一个位置，最大元素放在最后一个位置，而将枢纽元与倒数第二个元素互换。这样做的好处不仅是减少了交换次数，还提供了一个警戒线，即由于第一个元素一定比枢纽元小，所以可以把它作为$j$的警戒线，同理倒数第一个元素可以作为 $i$ 的警戒线<br>这时分割策略也相应进行一下调整，即$i$从第二个元素开始，而$j$从第倒数第三个元素开始</p>
<h3 id="选择问题的线性期望时间算法——快速选择"><a href="#选择问题的线性期望时间算法——快速选择" class="headerlink" title="选择问题的线性期望时间算法——快速选择"></a>选择问题的线性期望时间算法——快速选择</h3><p>之前，我们可以通过使用优先队列，以时间 $O(N + k\log N)$ 找到第 k 个最大（或最小）元，对于查找中值的特殊情况，它给出一个 $O(N\log N)$算法<br>而快速选择算法虽然最坏情况的运行时间为 $O(N^2)$（由于分割不均衡，导致其中一个子数组为空的情况），但其平均运行时间为 $O(N)$<br>其基本思路与快速排序大同小异  </p>
<ol>
<li><p>如果 $S$ 中元素个数是 1 ，则返回该元素。如果正在使用小数组的截止方法且在截止范围内，则用插入排序将 $S$ 排序并返回第 k 个元素。</p>
</li>
<li><p>取 $S$ 中任一元素 $v$, 称之为枢纽元</p>
</li>
<li><p>将 $S - {v}$($S$中其余元素)划分为两个不相交的集合，$S_1 = {x\in S - {v}\space |\space x\leq v}$ 和 $S_2 = {x\in S - {v}\space |\space x\geq v}$  </p>
</li>
<li><p>步骤四有如下几种可能  </p>
<ul>
<li><p>如果 $k \leq|S_1|$，那么第 $k$ 个最小元必然在 $S_1$ 中，那么使用序列 $S_1$重复执行上述步骤；</p>
</li>
<li><p>如果 $k &gt; |S_1|+1$，那么第 $k$ 个最小元必然在 $S_2$ 中，那么使用序列 $S_2$ 重复执行上述步骤; </p>
</li>
<li><p>如果 $k = |S_1|+1$，那么第 $k$ 个最小元正好是枢纽元，返回该枢纽元，结束程序 </p>
</li>
</ul>
</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package sort;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public void insertSort(int[] a, int left,int right)&#123;</span><br><span class="line">        int[] temp = new int[right - left +1];</span><br><span class="line">        for (int i = left; i &lt;= right - 1; i++) &#123;</span><br><span class="line">            int min = a[i];</span><br><span class="line">            int minPos = i;</span><br><span class="line">            for (int j = i + 1; j &lt;= right; j++) &#123;</span><br><span class="line">                if (a[j] &lt; min) &#123;</span><br><span class="line">                    minPos = j;</span><br><span class="line">                    min = a[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swapElement(a,i,minPos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void quickSort(int[] a) &#123;</span><br><span class="line">        quickSort(a, 0, a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public void quickSort(int[] a, int left, int right) &#123;</span><br><span class="line">        //在 N &lt; 10 时使用插入排序</span><br><span class="line">        if (right - left &lt; 10) &#123;</span><br><span class="line">            insertSort(a,left,right);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int hubDollar = findHubDollar(a, left, right);</span><br><span class="line">        int center = (left + right) / 2;</span><br><span class="line">        swapElement(a, center, right - 1);</span><br><span class="line">        int i = left + 1;</span><br><span class="line">        int j = right - 2;</span><br><span class="line">        while ( i &lt;= j) &#123;</span><br><span class="line">            for (; a[i] &lt; hubDollar; i++);</span><br><span class="line">            for (; a[j] &gt; hubDollar; j--);</span><br><span class="line">            if (i &lt;= j) &#123;</span><br><span class="line">                swapElement(a, i++, j--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swapElement(a, i, right - 1);</span><br><span class="line">        quickSort(a, left, i - 1);</span><br><span class="line">        quickSort(a, i + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findHubDollar(int[] a, int left, int right) &#123;</span><br><span class="line">        int center = (left + right) / 2;</span><br><span class="line">        if (a[center] &lt; a[left]) &#123;</span><br><span class="line">            swapElement(a, center, left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[right] &lt; a[left]) &#123;</span><br><span class="line">            swapElement(a, right, left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[right] &lt; a[center]) &#123;</span><br><span class="line">            swapElement(a, right, center);</span><br><span class="line">        &#125;</span><br><span class="line">        return a[center];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swapElement(int[] a, int pos1, int pos2) &#123;</span><br><span class="line">        int temp = a[pos1];</span><br><span class="line">        a[pos1] = a[pos2];</span><br><span class="line">        a[pos2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayArray(int[] a) &#123;</span><br><span class="line">        for (int item : a) &#123;</span><br><span class="line">            System.out.print(item+&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        QuickSort quickSort = new QuickSort();</span><br><span class="line">        int[] a = &#123;5,2,8,3,1,2,9,20,26,22,17&#125;;</span><br><span class="line">        quickSort.displayArray(a);</span><br><span class="line">        quickSort.quickSort(a);</span><br><span class="line">        quickSort.displayArray(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="快速排序小结"><a href="#快速排序小结" class="headerlink" title="快速排序小结"></a>快速排序小结</h3><p>快速排序是实践中的一种快速的排序算法，在C++ 或对 Java 中基本类型的排序十分有用。它的平均运行时间是$O(N \log N)$。该算法之所以特别快，主要是由于非常精炼和高度优化的内部循环。它的最坏情况是 $O(N^2)$,但经过稍许努力，可使这些情形极难出现。  </p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h3><p>对于一个输入数据 $A_1,A_2,…,A_i(A_i\leq M)$ 我们可以建立一个大小为 M 的且被初始化全为0的 count 数组，当扫描到元素 $A_i$ 时，我们便让 $count[A_i] += 1$ 。当输入完毕后，扫描数组 count ，打印出排序结果</p>
<h3 id="桶排序小结"><a href="#桶排序小结" class="headerlink" title="桶排序小结"></a>桶排序小结</h3><p>桶排序虽然运行时间为 $O(M+N)$ 但其限制条件很强，一般只适用于小整数的情况。面对这些情况，使用快速排序之类的算法就有点小题大做了，这时便可以考虑桶排序</p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>当待排序的数据量很大，而所给内存很小时，上述的几种内部排序算法就无法满足条件，而需要接下来的外部排序算法。<br>外部排序算法通过每次执行从外存取得数据，装入内存，使内存装满，然后对内存中的数据进行排序，在转到外存这一重复操作来将数据进行排序。<br>它的实现思路与归并排序大同小异。</p>
<h3 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h3><p>首先我们将把每组排过序的记录称为<strong>顺串</strong>，并假设内存能容纳 $M$ 个记录，且有 $N$ 个待排序的记录    </p>
<p>接着对于外部排序有以下三种思路  </p>
<ul>
<li><p>简单算法（2路合并）<br>  该算法将需要 $\left\lceil \log N/M \right\rceil$ 趟工作，外加一趟初始的顺串构造，并且需要4个磁盘带 $T_{a1},T_{a2},T_{b1},T_{b2}$。  </p>
<p>  下面是具体思路  </p>
<ol>
<li><p>每次从 $N$ 个记录中取 $M$ 个记录，在内存中对它们进行排序，然后依次交替存在磁盘带 $T_{b1},T_{b2}$ 上  </p>
</li>
<li><p>每次取出 $T_{b1},T_{b2}$ 中的第一个顺串，对他们进行归并（参考归并排序），使之成为一个长度为 $2^iM$ 的顺串（$i$为执行步骤二和三的总次数），并将他们依次交替存放在 磁盘带 $T_{a1},T_{a2}$，直到$T_{b1},T_{b2}$ 取尽为止。</p>
</li>
<li><p>每次取出 $T_{a1},T_{a2}$ 中的第一个顺串，对他们进行归并（参考归并排序），使之成为一个长度为 $2^iM$ 的顺串（$i$为执行步骤二和三的总次数），并将他们依次交替存放在 磁盘带 $T_{b1},T_{b2}$，直到$T_{a1},T_{a2}$ 取尽为止。</p>
</li>
<li><p>重复执行步骤二、三，直到 $2^iM \geq N$</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>多路合并（k路合并）<br>  如果我们有额外的磁盘带，那么为了减少排序所需要的躺数，我们可以使用$k$路排序。<br>  它需要 $\left\lceil \log_k N/M \right\rceil$ 趟工作，外加一趟初始的顺串构造，并且需要 $2k$个 磁盘带 $T_{a1},T_{a2},…,T_{ak},T_{b1},T_{b2},…,T_{bk}$ </p>
<p>  下面是具体思路  </p>
<ol>
<li><p>每次从 $N$ 个记录中取 $M$ 个记录，在内存中对它们进行排序，然后依次交替存在磁盘带 $T_{b1},T_{b2},…,T_{bk}$ 上  </p>
</li>
<li><p>每次取出 $T_{b1},T_{b2},…,T_{bk}$ 中的第一个顺串，对他们进行归并（参考归并排序），使之成为一个长度为 $k^iM$ 的顺串（$i$为执行步骤二和三的总次数），并将他们依次交替存放在 磁盘带 $T_{a1},T_{a2},…,T_{ak}$，直到$T_{b1},T_{b2},…,T_{bk}$ 取尽为止。</p>
</li>
<li><p>每次取出 $T_{a1},T_{a2},…,T_{ak}$ 中的第一个顺串，对他们进行归并（参考归并排序），使之成为一个长度为 $2^iM$ 的顺串（$i$为执行步骤二和三的总次数），并将他们依次交替存放在 磁盘带 $T_{b1},T_{b2},…,T_{bk}$，直到$T_{a1},T_{a2},…,T_{ak}$ 取尽为止。</p>
</li>
<li><p>重复执行步骤二、三，直到 $k^iM \geq N$</p>
<p>示例图如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uk6qsj30nk0lwq3o.jpg" data-fancybox="group" data-caption="QQ截图20200204221026.jpg" class="fancybox"><img alt="QQ截图20200204221026.jpg" title="QQ截图20200204221026.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uk6qsj30nk0lwq3o.jpg" class="lazyload"></a>  </p>
<p>这里与第一种简单算法（二路合并）不同的地方在于归并这一操作。<br>在二路合并中，我们只需比较在两个顺串中一共两个元素的大小，这可以用简单的逻辑判断来实现<br>但在多路合并中，我们需要比较 k 个顺串中一共 k 个元素的大小，这里我们就不能用简单的逻辑判断来实现，而是可以通过构造一个优先队列，通过一个 deleteMin 操作来实现输出最小元，然后通过一个 insert 操作来新增一个元素用于同堆中剩下的其他元素进行比较</p>
</li>
</ol>
</li>
<li><p>多项合并<br>  多路合并的主要缺点在于需要额外的大量磁盘带（$2k$），例如针对一个3路排序，它就需要额外的6个磁盘带。<br>  而多项合并只需要 $k+1$ 个磁盘带<br>  多项合并的第一次分配是十分重要的，对于一个 $k$ 路合并，如果顺串的个数是一个斐波那契数 $F_N$，那么分配这些顺串的最好方式是分裂为 $F^{(k)}(N-1),F^{(k)}(N-2),F^{(k)}(N-3),…,F^{(k)}(N-k)$，<br>  使得$F^{(k)}(N) = F^{(k)}(N-1)+F^{(k)}(N-2)+F^{(k)}(N-3)+…+F^{(k)}(N-k)$  </p>
<p>  如果顺串的个数不是一个斐波那契数，则用一些哑顺串填补磁盘带，使个数变为一个斐波那契数。</p>
<p>  一个多项合并的具体思路如下($k=2$)，他需要3个额外磁盘带$T_1,T_2,T_3$  </p>
<ol>
<li>用上述方式，将顺串分配给 $T_2,T_3$，其中$T_2$分到$F_{N-1}$ 个，$T_3$ 分到 $F_{N-2}$ 个  </li>
<li>归并含有顺串的两个磁盘带（例如$T_2,T_3$），将归并好的顺串存入到没有顺串的磁盘带（例如 $T_1$），归并之后 $T_1$ 含有 $F_{N-2}$ 个顺串， $T_2$ 有 $F_{N-1} - F_{N-2} = F_{N-3}$ 个顺串，$T_3$ 有0个顺串</li>
<li><p>重复步骤二，直到顺串的个数为 1 且只有一个磁盘带中有顺串为止  </p>
<p>示例图如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj519j30lm04qt8r.jpg" data-fancybox="group" data-caption="QQ截图20200204220930.jpg" class="fancybox"><img alt="QQ截图20200204220930.jpg" title="QQ截图20200204220930.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj519j30lm04qt8r.jpg" class="lazyload"></a></p>
</li>
</ol>
</li>
</ul>
<p>还有一个需要考虑的地方就是如何考虑构造顺串<br>虽然有种简单的办法，那就是将 $M$ 个记录全读入到内存中(内存只能容纳 $M$ 个记录) ，然后对这 $M$ 个记录进行排序，得到一个顺串。<br>但是这种方法并不好，我们还有一个更为流行的方法，称为<strong>替换选择</strong>。它的步骤如下  </p>
<ul>
<li><p>首先，将 $M$ 个记录读入内存，并构造一个优先队列。  </p>
</li>
<li><p>然后对优先队列执行一次 deleteMin 操作，输出一个最小值，此时从输入磁盘带上读入一个记录，比较该记录与输出的记录的大小。  </p>
<ul>
<li><p>若该记录小于输出的记录，则不能把它放入当前的顺串，而是将它放入一个死区（类似堆排序） </p>
</li>
<li><p>若该记录大于输出的记录，那么就插入该记录    </p>
</li>
</ul>
</li>
<li><p>直到当前优先队列的大小变为0，表示一个顺串构造完毕，此时用死区的记录以及从输入磁盘带上读取的新记录再构造一个新的优先队列，重复以上步骤，直到输入磁盘带中的记录读完，完成顺串的构造   </p>
</li>
</ul>
<p>示例图如下  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj0u2j30l80gr3yy.jpg" data-fancybox="group" data-caption="QQ截图20200204220917.jpg" class="fancybox"><img alt="QQ截图20200204220917.jpg" title="QQ截图20200204220917.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj0u2j30l80gr3yy.jpg" class="lazyload"></a></p>
<h2 id="一些排序算法运行时间的比较"><a href="#一些排序算法运行时间的比较" class="headerlink" title="一些排序算法运行时间的比较"></a>一些排序算法运行时间的比较</h2><p><a href="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj3lpj30py09owf7.jpg" data-fancybox="group" data-caption="QQ截图20200204220815.jpg" class="fancybox"><img alt="QQ截图20200204220815.jpg" title="QQ截图20200204220815.jpg" data-src="http://ww1.sinaimg.cn/large/006buNqily1gbkq7uj3lpj30py09owf7.jpg" class="lazyload"></a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">f1rry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/07/排序/">http://yoursite.com/2020/02/07/排序/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">F1rry's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA    </a><a class="post-meta__tags" href="/tags/数据结构/">数据结构    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/10/图论算法/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>图论算法</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/03/java 散列/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>JAVA 散列</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/03/java 散列/" title="JAVA 散列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-03</div><div class="relatedPosts_title">JAVA 散列</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/01/优先队列/" title="优先队列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-01</div><div class="relatedPosts_title">优先队列</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/10/图论算法/" title="图论算法"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-10</div><div class="relatedPosts_title">图论算法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/AOP/" title="Spring学习 AOP"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">Spring学习 AOP</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/04/依赖注入DI/" title="Spring学习 依赖注入"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-04</div><div class="relatedPosts_title">Spring学习 依赖注入</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/29/保护Web应用/" title="Spring学习 依赖注入"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-29</div><div class="relatedPosts_title">Spring学习 依赖注入</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By f1rry</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>