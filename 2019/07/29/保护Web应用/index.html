<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Spring学习 依赖注入 | F1rry's blog</title><meta name="description" content="Spring学习 依赖注入"><meta name="keywords" content="JAVA,Spring,Spring Security"><meta name="author" content="f1rry"><meta name="copyright" content="f1rry"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring学习 依赖注入"><meta name="twitter:description" content="Spring学习 依赖注入"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="Spring学习 依赖注入"><meta property="og:url" content="http://yoursite.com/2019/07/29/保护Web应用/"><meta property="og:site_name" content="F1rry's blog"><meta property="og:description" content="Spring学习 依赖注入"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/07/29/保护Web应用/"><link rel="prev" title="优先队列" href="http://yoursite.com/2020/02/01/优先队列/"><link rel="next" title="Spring学习 AOP" href="http://yoursite.com/2019/07/20/AOP/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">F1rry's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-Security简介"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Spring Security简介</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Spring-Security-的模块"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Spring Security 的模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#过滤Web请求"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">过滤Web请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#编写简单的安全性配置"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">编写简单的安全性配置</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#选择查询用户详细信息的服务-重载configure-AuthenticationManagerBuilder-方法"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">选择查询用户详细信息的服务(重载configure(AuthenticationManagerBuilder)方法)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用基于内存的用户存储"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">使用基于内存的用户存储</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于数据库表进行认证"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">基于数据库表进行认证</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于-LDAP-进行认证"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">基于 LDAP 进行认证</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#配置自定义的用户服务"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">配置自定义的用户服务</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#拦截请求-重载configure-HttpSecurity-方法"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">拦截请求(重载configure(HttpSecurity)方法)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#认证用户"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">认证用户</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#保护方法应用"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">保护方法应用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用-Secured-注解限制方法调用"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">使用 @Secured 注解限制方法调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用-JSR-250-的-RolesAllowed-注解"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">使用 JSR-250 的 @RolesAllowed 注解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#使用表达式实现方法级别的安全性"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">使用表达式实现方法级别的安全性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#表述方法访问规则"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">表述方法访问规则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#过滤方法的输入与输出"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">过滤方法的输入与输出</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Security简介"><span class="toc-number">1.</span> <span class="toc-text">Spring Security简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security-的模块"><span class="toc-number">1.1.</span> <span class="toc-text">Spring Security 的模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤Web请求"><span class="toc-number">1.2.</span> <span class="toc-text">过滤Web请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写简单的安全性配置"><span class="toc-number">1.3.</span> <span class="toc-text">编写简单的安全性配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择查询用户详细信息的服务-重载configure-AuthenticationManagerBuilder-方法"><span class="toc-number">2.</span> <span class="toc-text">选择查询用户详细信息的服务(重载configure(AuthenticationManagerBuilder)方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用基于内存的用户存储"><span class="toc-number">2.1.</span> <span class="toc-text">使用基于内存的用户存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于数据库表进行认证"><span class="toc-number">2.2.</span> <span class="toc-text">基于数据库表进行认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-LDAP-进行认证"><span class="toc-number">2.3.</span> <span class="toc-text">基于 LDAP 进行认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置自定义的用户服务"><span class="toc-number">2.4.</span> <span class="toc-text">配置自定义的用户服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拦截请求-重载configure-HttpSecurity-方法"><span class="toc-number">3.</span> <span class="toc-text">拦截请求(重载configure(HttpSecurity)方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#认证用户"><span class="toc-number">4.</span> <span class="toc-text">认证用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保护方法应用"><span class="toc-number">5.</span> <span class="toc-text">保护方法应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Secured-注解限制方法调用"><span class="toc-number">5.1.</span> <span class="toc-text">使用 @Secured 注解限制方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-JSR-250-的-RolesAllowed-注解"><span class="toc-number">5.2.</span> <span class="toc-text">使用 JSR-250 的 @RolesAllowed 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用表达式实现方法级别的安全性"><span class="toc-number">6.</span> <span class="toc-text">使用表达式实现方法级别的安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表述方法访问规则"><span class="toc-number">6.1.</span> <span class="toc-text">表述方法访问规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤方法的输入与输出"><span class="toc-number">6.2.</span> <span class="toc-text">过滤方法的输入与输出</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Spring学习 依赖注入</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-07-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-08-07</time><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 19 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>学习内容：  </p>
<ul>
<li>Spring Security介绍  </li>
<li>使用Servlet 规范中的Filter保护 Web应用  </li>
<li>基于数据库和LDAP进行认证  </li>
</ul>
<h2 id="Spring-Security简介"><a href="#Spring-Security简介" class="headerlink" title="Spring Security简介"></a>Spring Security简介</h2><p>Spring Security是为基于Spring的应用程序提供声明式安全保护的安全性框架。 Spring Security 提供了完整的安全性解决方案,它能够在Web请求级别和方法调用级别身份认证和授权。  </p>
<p>因为基于Spring框架，所以Spring Security 充分利用了 <strong>依赖注入</strong> 和 <strong>面向切面</strong> 的技术。  </p>
<p>在Spring Security 3.2版本中，从两个角度来解决安全性问题  </p>
<ul>
<li>使用 Servlet 规范中的Filter保护Web请求并限制URL级别的访问  </li>
<li>使用 Spring AOP 保护方法调用 ———借助于对象代理和使用通知，能够确保只有具备适当权限的用户才能访问安全保护的方法  </li>
</ul>
<h3 id="Spring-Security-的模块"><a href="#Spring-Security-的模块" class="headerlink" title="Spring Security 的模块"></a>Spring Security 的模块</h3><p>不管你想使用Spring Security保护哪种类型的应用程序(这里只讲保护Web应用程序)，第一件需要做的就是将Spring Security模块添加到应用程序的类路径下。<br>它一共有11个模块，如下所示<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7lhc8q1z5j30oi0os43w.jpg" data-fancybox="group" data-caption="QQ截图20191004003057.png" class="fancybox"><img alt="QQ截图20191004003057.png" title="QQ截图20191004003057.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7lhc8q1z5j30oi0os43w.jpg" class="lazyload"></a><br>其中箭头标注的，无论哪种应用都是必须的，Web应用程序还需要添加 Web 模块  </p>
<h3 id="过滤Web请求"><a href="#过滤Web请求" class="headerlink" title="过滤Web请求"></a>过滤Web请求</h3><p>借助于Spring的小技巧，我们只需配置一共Filter就可以提供各种安全性功能了。<br>DelegatingFilterProxy 是一个特殊的 Servlet Filter，它本身所做的工作并不多。知识将一个工作委托给一共 javax.servlet.Filter 实现类。这个实现类作为一个\<bean>注册在Spring应用的上下文中，如图所示<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7lhi8omn9j30nf07b0u3.jpg" data-fancybox="group" data-caption="QQ截图20191004003626.png" class="fancybox"><img alt="QQ截图20191004003626.png" title="QQ截图20191004003626.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7lhi8omn9j30nf07b0u3.jpg" class="lazyload"></a>  </bean></p>
<p>DelegatingFilterProxy 的配置方法如下  </p>
<ul>
<li><p>在传统的 web.xml 中配置  </p>
<p>  <a href="http://ww1.sinaimg.cn/large/006buNqily1g7lhkdn2n0j30k1057js1.jpg" data-fancybox="group" data-caption="QQ截图20191004003641.png" class="fancybox"><img alt="QQ截图20191004003641.png" title="QQ截图20191004003641.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7lhkdn2n0j30k1057js1.jpg" class="lazyload"></a>  </p>
<p>  注意这里将\<filter-name>设置成了 springSecurityFilterChain<br>  当我们配置 Spring Security 到 Web 安全性中， 这里会有一个名为 springSecurityFilterChain 的 Filter bean ,DelegatingFilterProxy 会将过滤逻辑委托给它  </filter-name></p>
</li>
<li><p>以Java的方式来配置  </p>
<pre><code>package spitter.config;
import org,springframework.security.web.context.AbstractSecurityWebApplicationInitializer;  

public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}  
</code></pre><p>  AbstractSecurityWebApplicationInitializer 实现了 WebApplicationInitializer，因此Spring会发现他，并用它在Web容器中注册DelegatingFilterProxy 。  </p>
</li>
</ul>
<p>不管是用哪种方式来配置 DelegatingFilterProxy ，它都会拦截发送应用中的请求，并将请求委托给ID 为 springSecurityFilterChain bean .  </p>
<p>springSecurityFilterChain 本身是另一个特殊的 Filter,它也被成为 FilterChainProxy. 它可以链接任意一个或多个其他的 Filter. Spring Security 依赖一系列 Servlet Filter 来提供不同的安全特性。<br>你不需要显示声明 springSecurityFilterChain 以及它所链接在一起的其他Filter。当我们启用 Web 安全性的时候，会自动创建这些Filter。  </p>
<h3 id="编写简单的安全性配置"><a href="#编写简单的安全性配置" class="headerlink" title="编写简单的安全性配置"></a>编写简单的安全性配置</h3><p>在Spring 3.2之前 安全性配置是很麻烦的<br>但在 Spring 3.2 之后，引入了新的Java 配置方案，完全不在需要通过XML来配置安全性功能了。<br>以下是最简单的安全性配置  </p>
<pre><code>package spitter.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigureAdapter;
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{
}
</code></pre><p>@EnableWebSecurity 注解将会启用 Web 安全功能。但他本身并没有什么用处, Spring Security 必须配置在一个实现了 WebSecurityConfigurer 的 bean中，或者拓展了WebSecurityConfigurerAdapter。 在Spring 应用上下文中，任何实现了 WebSecurityConfigurer 的bean都可以用来配置 Spring Security ，但是最简单的方式还是拓展 WebSecurityConfigurerAdapter 类  </p>
<p>@EnableWebSecurity 可以启用任意Web应用的安全性功能，不过，如果你的应用时Spring MVC 那应该考虑使用 @EnableWebMvcSecurity 替代它。 该注解还配置了一个 Spring MVC 参数解析器，这样的话处理器方法就能狗通过带有 @AuthenticationPrincipal 注解的参数获得认证用户的 principal。它同时还配置了一个 bean ，在使用 Spring 表单绑定标签库来定义表单时，这个 bean 会自动添加一个 CSRF token 输入域。 </p>
<pre><code>package spitter.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebMvcSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigureAdapter;
@Configuration
@EnableWebMvcSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{
}
</code></pre><p>除此之外，我们还可以通过重载 WebSecurityConfigureAdapter 的 configure() 方法来配置 Web 安全性。<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7m613h2sqj30wz0cptbe.jpg" data-fancybox="group" data-caption="QQ截图20191004144512.png" class="fancybox"><img alt="QQ截图20191004144512.png" title="QQ截图20191004144512.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7m613h2sqj30wz0cptbe.jpg" class="lazyload"></a>  </p>
<p>当我们没有重写上述三个方法的任何一个时，默认的Filter 即 configure(HttpSecurity) 实际上等同于  </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .anyRequest().authenticated()
        .and()
        .formLogin().and()
        .httpBasic()
}
</code></pre><p>这个默认配置中 authorizeRequests() 和 anyRequest().authenticated() 会要求所有进入应用的HTTP请求都要进行认证。formLogin()使Spring Security支持基于表单的登录   httpBasic() 使应用支持 HTTP Basic方式的认证。  </p>
<p>同时，因为我们没有重载 configure(AuthenticationManagerBuilder)方法，所以没有用户存储支撑认证功能。</p>
<p>所以为了让 Spring Security 满足我们应用的需求，还需要添加一点其他配置，具体来讲:  </p>
<ul>
<li>配置用户存储 (重载configure(AuthenticationManagerBuilder)方法)</li>
<li>指定哪些请求需要认证，哪些请求不需要认证，以及所需要的权限(重载configure(HttpSecurity)方法)  </li>
<li>提供一个自定义的登录页面，替代原来简单的默认登录页。 </li>
</ul>
<h2 id="选择查询用户详细信息的服务-重载configure-AuthenticationManagerBuilder-方法"><a href="#选择查询用户详细信息的服务-重载configure-AuthenticationManagerBuilder-方法" class="headerlink" title="选择查询用户详细信息的服务(重载configure(AuthenticationManagerBuilder)方法)"></a>选择查询用户详细信息的服务(重载configure(AuthenticationManagerBuilder)方法)</h2><p>Spring Security 非常灵活，能够基于各种数据存储来认证用户  </p>
<ul>
<li>内存  </li>
<li>关系型数据库  </li>
<li>LDAP  </li>
</ul>
<h3 id="使用基于内存的用户存储"><a href="#使用基于内存的用户存储" class="headerlink" title="使用基于内存的用户存储"></a>使用基于内存的用户存储</h3><pre><code>package spitter.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebMvcSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigureAdapter;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
@Configuration
@EnableWebMvcSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{
        auth.inMemoryAuthentication()
                    .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;).and()
                .withUser(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;);
    }
}
</code></pre><ul>
<li>imMemoryAuthentication()指定使用基于内存的用户存储  </li>
<li>withUser()方法为内存用户存储添加新的用户，其用户名为传入其中的字符串</li>
<li>password()方法为用户指定密码  </li>
<li>roles() 为给定用户授予一个或多个角色权限(它是 authorities() 方法的简写形式，roles()方法所给定的值都会添加一个”ROLE_”前缀，并将其作为权限授予给用户)  </li>
</ul>
<p>以下是其他一些方法和它们的功能描述<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7m77vyszyj30rp0o6adu.jpg" data-fancybox="group" data-caption="QQ截图20191004152616.png" class="fancybox"><img alt="QQ截图20191004152616.png" title="QQ截图20191004152616.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7m77vyszyj30rp0o6adu.jpg" class="lazyload"></a>  </p>
<p>基于内存的用户存储，适用于调试和开发人员的测试。<br>对于生产环境，通常最好将用户数据保存在某种类型的数据库之中。  </p>
<h3 id="基于数据库表进行认证"><a href="#基于数据库表进行认证" class="headerlink" title="基于数据库表进行认证"></a>基于数据库表进行认证</h3><p>最少配置如下所示  </p>
<pre><code>@Autowired
DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.jdbcAuthentication()
            .dataSource(dataSource);
}
</code></pre><p>该配置会使用默认的用户查询功能，查询语句如下<br>    <a href="http://ww1.sinaimg.cn/large/006buNqily1g7m7iu2eg6j30q00bd41q.jpg" data-fancybox="group" data-caption="QQ截图20191004153652.png" class="fancybox"><img alt="QQ截图20191004153652.png" title="QQ截图20191004153652.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7m7iu2eg6j30q00bd41q.jpg" class="lazyload"></a></p>
<p>第一个查询用于用户认证<br>第二个查询用于用户授权，查看用户被赋予的角色<br>第三个查询用于用户授权，查看用户所在用户组所赋予的权限  </p>
<p>当默认的查询功能不符合我们需求时，我们就需要设置自己的查询。可以通过如下方式  </p>
<pre><code>@Autowired
DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.jdbcAuthentication()
            .dataSource(dataSource)
            .usersByUsernameQuery(
                    &quot;select username,password,true&quot; +
                    &quot; from Spitter where username=?&quot;)
            .authoritiesByUsernameQuery(
                    &quot;select username, &apos;ROLE_USER&apos; from Spitter where username=?&quot;
            );
}
</code></pre><ul>
<li>usersByUsernameQuery() 对应上面第一个查询语句，用于用户认证</li>
<li>authoritiesByUsernameQuery() 对应上面第二个查询语句，用于用户授权验证  </li>
</ul>
<p>同时还可以指定一个密码转换器，防止黑客窃取用户密码  </p>
<pre><code>@Autowired
DataSource dataSource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.jdbcAuthentication()
            .dataSource(dataSource)
            .usersByUsernameQuery(
                    &quot;select username,password,true&quot; +
                    &quot; from Spitter where username=?&quot;)
            .authoritiesByUsernameQuery(
                    &quot;select username, &apos;ROLE_USER&apos; from Spitter where username=?&quot;
            .passwordEncoder(new StandarPasswordEncoder(&quot;53cr3t&quot;))
            );
}
</code></pre><p>passwordEncoder()方法可以接受Spring Security 中 PasswordEncoder 接口的任意实现。<br>Spring Security 的加密模块包括了三个这样的实现:  </p>
<ul>
<li>BCryptPasswordEncoder</li>
<li>NoOpPasswordEncoder  </li>
<li>StandardPasswordEncoder  </li>
</ul>
<p>如果内置的实现无法满足需求，你可以提供自己的实现，<br>PasswordEncoder 接口定义如下  </p>
<pre><code>public interface PasswordEncoder {
    String encode(CharSequence rawPassword);
    boolean matches(CharSequence rawPassword, String encodedPassword);
}
</code></pre><h3 id="基于-LDAP-进行认证"><a href="#基于-LDAP-进行认证" class="headerlink" title="基于 LDAP 进行认证"></a>基于 LDAP 进行认证</h3><p>简单配置如下  </p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchFilter(&quot;member={0}&quot;);
}
</code></pre><ul>
<li>userSearchFilter() 对应上述第一个查询语句，用于用户认证</li>
<li>groupSearchFilter() 对应上述第三个查询语句，用于用户授权，检查用户所在组被赋予的权限。  </li>
</ul>
<p>当不配置上述两个方法的基础查询时，表名搜索会在LDAP层级结构的根开始。但是我们可以指定查询基础来改变这个默认行为。</p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearcheBase(&quot;ou=people&quot;)
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchBase(&quot;ou=groups&quot;)
            .groupSearchFilter(&quot;member={0}&quot;);
}  
</code></pre><p><strong>配置密码比对</strong><br>使用 passwordCompare() 方法 </p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearcheBase(&quot;ou=people&quot;)
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchBase(&quot;ou=groups&quot;)
            .groupSearchFilter(&quot;member={0}&quot;)
            .passwordCompare();
}
</code></pre><p>默认情况下，在登录表单中提供的密码将会与用户的LDAP条目中的userPassword属性进行比对。如果密码被保存在不同的属性中，可以通过 passwordAttribute() 方法来声明密码属性的名称。同时我们可以通过passwordEncoder()方法对其进行加密  </p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearcheBase(&quot;ou=people&quot;)
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchBase(&quot;ou=groups&quot;)
            .groupSearchFilter(&quot;member={0}&quot;)
            .passwordCompare()
            .passwordEncoder(new Md5PasswordEncoder())
            .passwordAttribute(&quot;passcode&quot;);
}  
</code></pre><p><strong>引用远程的LDAP服务器</strong><br>可以使用 contextSource()方法来配置远程地址  </p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearcheBase(&quot;ou=people&quot;)
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchBase(&quot;ou=groups&quot;)
            .groupSearchFilter(&quot;member={0}&quot;)
            .contextSource()
                .url(&quot;ldap://habuma.com:389/dc=habuma,dc=com&quot;);
}
</code></pre><p><strong>引用嵌入式的LDAP服务器</strong><br>同样使用 contextSource() 方法来配置</p>
<pre><code>@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.ldapAuthentication()
            .userSearcheBase(&quot;ou=people&quot;)
            .userSearchFilter(&quot;{uid={0}}&quot;)
            .groupSearchBase(&quot;ou=groups&quot;)
            .groupSearchFilter(&quot;member={0}&quot;)
            .contextSource()
                .root(&quot;classpath:users.ldif&quot;);
}  
</code></pre><h3 id="配置自定义的用户服务"><a href="#配置自定义的用户服务" class="headerlink" title="配置自定义的用户服务"></a>配置自定义的用户服务</h3><p>当我们使用菲关系型数据库，例如mongodb,redis时，就需要自定义用户服务了。我们需要提供一个自定义的 UserDetailsService 接口实现<br>UserDetailsService 接口定义如下  </p>
<pre><code>public interface UserDetailsService{
    Userdetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
</code></pre><p>我们所需要做的就是实现 loadUserByUsername() 方法，根据给定的用户名来查找用户。  </p>
<p>以下是一个 UserDetailsService 实现<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7ma2kha1fj30qd0o0qag.jpg" data-fancybox="group" data-caption="QQ截图20191004170440.png" class="fancybox"><img alt="QQ截图20191004170440.png" title="QQ截图20191004170440.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7ma2kha1fj30qd0o0qag.jpg" class="lazyload"></a>  </p>
<p>另外一种值得考虑的方案就是修改Spitter，让其实现UserDetails。这样的话，loadUserByUsername()就能直接返回 Spitter 对象了，而不必将它的值复制到 User 对象</p>
<p>在自己实现了一个 UserDetailsService 后，我们就可以使用它了</p>
<pre><code>@Autowired
SpitterRepository spitterRepository;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
    auth.userDetailsService(new SpitterUserService(spitterRepository));
}
</code></pre><h2 id="拦截请求-重载configure-HttpSecurity-方法"><a href="#拦截请求-重载configure-HttpSecurity-方法" class="headerlink" title="拦截请求(重载configure(HttpSecurity)方法)"></a>拦截请求(重载configure(HttpSecurity)方法)</h2><p>在Web应用中，有些请求需要认证，有些请求需要授权，有些请求什么都不需要，这里就需要通过重载 configure(HttpSecurity) 方法来实现了<br>需要注意的是，在配置时，描述越详细的请求应放在最前面，以防止被覆盖<br>示例如下  </p>
<pre><code>    protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .antMatchers(&quot;spitters/me&quot;).authenticated()
            .antMatchers(HttpMethod.POST,&quot;spittles&quot;).authenticated()
            .anyRequest().permitAll();
}  
</code></pre><p>其中  </p>
<ul>
<li>authorizeRequests() 返回的对象的方法用来配置请求级别的安全性细节  </li>
<li>antMatchers() 支持Ant风格的通配符，用来匹配路径  </li>
<li>regaxMatchers() 支持正则表达式，用法同上  </li>
<li>anyRequest() 表示任意请求</li>
</ul>
<p>还有其他的方法如下所示<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7mahk4yyij30m80ov790.jpg" data-fancybox="group" data-caption="QQ截图20191004171926.png" class="fancybox"><img alt="QQ截图20191004171926.png" title="QQ截图20191004171926.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7mahk4yyij30m80ov790.jpg" class="lazyload"></a></p>
<p>遗憾的是，上面的方法大多都是一维的，也就是说，我们不能在相同的路径上同时使用上面的方法。<br>幸运的是，我们可以借助 access()方法和 Spring表达式语言(SpEL)来提供多种访问限制  </p>
<p><strong>使用Spring表达式进行安全保护</strong> </p>
<p>Spring Security 通过一些安全性相关的表达式拓展了Spring 表达式语言，表格如下<br><a href="http://ww1.sinaimg.cn/large/006buNqily1g7mb17b294j30nx0o5q79.jpg" data-fancybox="group" data-caption="QQ截图20191004173756.png" class="fancybox"><img alt="QQ截图20191004173756.png" title="QQ截图20191004173756.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7mb17b294j30nx0o5q79.jpg" class="lazyload"></a>   </p>
<p>用法如下   </p>
<pre><code>.antMatchers(&quot;spitters/me&quot;)
    .access(&quot;hasRole(&apos;ROLE_SPITTER&apos;) and hasIpAddress(&apos;192.168.1.2&apos;)&quot;)
</code></pre><p><strong>强制通道的安全性</strong>  </p>
<p>下例将强制要求对”/spitter/form”的请求，需要使用HTTPS协议，并自动将请求重定向到HTTPS上 </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .antMatchers(&quot;spitters/me&quot;).authenticated()
            .antMatchers(HttpMethod.POST,&quot;spittles&quot;).authenticated()
            .anyRequest().permitAll()
        .and()
        .requiresChannel()
            .antMatchers(&quot;spitter/form&quot;).requiresSecure();
}
</code></pre><p>下例会对”/“的请求，重定向到HTTP上  </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            .antMatchers(&quot;spitters/me&quot;).authenticated()
            .antMatchers(HttpMethod.POST,&quot;spittles&quot;).authenticated()
            .anyRequest().permitAll()
        .and()
        .requiresChannel()
            .antMatchers(&quot;spitter/form&quot;).requiresSecure()
            .antMatchers(&quot;/&quot;).requiresInsecure();
}
</code></pre><p><strong>防止CSRF攻击</strong>   </p>
<p>Spring Security3.2开始，默认就会启用 CSRF 防护，它通过一个同步 token方式来实现CSRF防护的功能。<br>它将会拦截状态变化的请求。并检查 CSRF token。 如果请求中不包含 CSRF Token的话，或者 token 不能与服务器端的token相匹配，请求将会失败，并抛出 CsrfException 异常。  </p>
<p>这意味着应用中所有的表单必须在一个”_csrf”域中提交token。<br>而Spring Security 已经简化了将 token放到请求的属性中这一任务。<br>以下是两个示例   </p>
<ul>
<li><p>Thymleaf作为页面模板  </p>
<pre><code>&lt;form method=&quot;POST&quot; th:action=&quot;@{/spittles}&quot;&gt;
    ...
&lt;/form&gt;
</code></pre></li>
<li><p>JSP作为页面模板  </p>
<pre><code>&lt;input type=&quot;hidden&quot; name=&quot;${_csrf.parameterName}&quot; value=&quot;${_csrf.token}&quot; /&gt;  
</code></pre></li>
</ul>
<p>我们也可以禁用 CSRF 防护(不推荐)  </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http.csrf().disable();
}  
</code></pre><h2 id="认证用户"><a href="#认证用户" class="headerlink" title="认证用户"></a>认证用户</h2><p>提供自定义认证表单</p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http
        .formLogin()
            .loginPage(&quot;/login&quot;)
    ......
}
</code></pre><p>对指定域启用HTTP Basic 认证</p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http
        .formLogin()
            .loginPage(&quot;/login&quot;)
        .and()
        .httpBasic()
            .realmName(&quot;Spittr&quot;)
        .and()
    ......
}  
</code></pre><p>启用Remember-me功能 </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http
        .formLogin()
            .loginPage(&quot;/login&quot;)
        .and()
        .rememberMe()
            .tokenValiditySeconds(2419200)
            .key(&quot;spittrKey&quot;)
    ......
}  
</code></pre><p>退出  </p>
<pre><code>protected void configure(HttpSecurity http) throws Exception {
    http
        .formLogin()
            .loginPage(&quot;/login&quot;)
        .and()
        .logout()
            .logoutSuccessUrl(&quot;/&quot;)
            .logoutUrl(&quot;/signout&quot;)      //不设置时，默认登出路径为&quot;/logout&quot;
    ......
}  
</code></pre><h2 id="保护方法应用"><a href="#保护方法应用" class="headerlink" title="保护方法应用"></a>保护方法应用</h2><p>上面的方法是用于保护应用的 Web 层，这种保护是比较笼统的，你不能执行更细粒度的保护。 例如当出现了一个 URL ，管理员和普通用户都能访问，但管理员可以查看所有用户的信息，但普通用户只能查看自己的信息时，上述保护 Web 层的方法就显得有点鸡肋了，因为如果你想实现这种需求，运用上述方法，你只能写两个不同的方法来分别响应不同的请求了。  </p>
<p>所以现在我们学习应该如何保护场景后面的方法，这样就能保证如果用户不具备权限的话，就无法执行相应的逻辑了，上述的例子你就可以将其合并为一个方法。  </p>
<p>Spring Security 提供了三种不同的安全注解：  </p>
<ul>
<li>Spring Security 自带的 @Secured 注解  </li>
<li>JSR-250 的 @RolesAllowed 注解  </li>
<li>表达式驱动的注解，包括@PrsAuthorize、@PostAuthorize、@PreFilter、@PostFilter<br>@Secured 和 @RolesAllowed 方案非常类似，能够基于用户所授予的权限限制对方法的访问。当我们需要在方法上定义更灵活的安全规则时， Spring Security 提供了@PreAuthorize 和 @PostAuthorize 而 @PreFilter 、 @PostFilter 能够过滤方法返回的以及传入方法的集合  </li>
</ul>
<h3 id="使用-Secured-注解限制方法调用"><a href="#使用-Secured-注解限制方法调用" class="headerlink" title="使用 @Secured 注解限制方法调用"></a>使用 @Secured 注解限制方法调用</h3><p>在 Spring 中，如果要启用基于注解的方法安全性，关键之处在于要在配置类上使用 @EnableGlobalMethodSecurity。  </p>
<p>例子如下所示  </p>
<pre><code>@Configuration
@EnableGlobalMethodSecurity(securedEnabled=true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

}
</code></pre><p><strong>注意</strong>  </p>
<ul>
<li>@EnableGlobalMethodSecurity 启用的是基于注解的<strong>方法安全性</strong>  </li>
<li>@EnableGlobalMethodSecurity 中的securedEnabled属性的值为 true 时，将会创建一个切点，这样的话 Spring Security 切面就会包装带有 @Secured 注解的方法。</li>
<li>GlobalMethodSecurityConfiguration 类能够为<strong>方法级别</strong>的安全性提供更精细的配置</li>
<li>@EnableWebSecurity 启用的是基于注解的<strong>Web安全性</strong>  </li>
<li>WebSecurityConfigurerAdapter 类能够为 <strong>Web级别</strong>的安全性提供配置  </li>
</ul>
<p>同样的，我们可以通过重载 GlobalMethodSecurityConfiguration 的 configure() 方法来实现 Web层的安全配置中设置认证：  </p>
<pre><code>@Configuration
@EnableGlobalMethodSecurity(securedEnabled=true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{
        auth.inMemoryAuthentication()
                    .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;).and()
                .withUser(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;);
    }
}  
</code></pre><p>我们还可以重载 createExpressionHandler() 方法，提供一些自定义的安全表达式处理行为  </p>
<p>然后我们就可以在控制器中使用 @Secured 注解了  </p>
<pre><code>@Secured({&quot;ROLE_SPITTER&quot;,&quot;ROLE_ADMIN&quot;})
public void addSpittle(Spittle spittle) {

}
</code></pre><p>如果方法被没有认证的用户或没有所需权限的用户调用，保护这个方法的切面将抛出一个 Spring Security 异常( AuthenticationException 或 AccessDeniedException)。它们是非检查型异常，但这个异常最终必须要被捕获和处理。如果被保护的方法是在 Web 请求中调用的，这个异常会被 Spring Security 的过滤器自动处理。否则的话，你需要编写代码来处理这个异常.</p>
<h3 id="使用-JSR-250-的-RolesAllowed-注解"><a href="#使用-JSR-250-的-RolesAllowed-注解" class="headerlink" title="使用 JSR-250 的 @RolesAllowed 注解"></a>使用 JSR-250 的 @RolesAllowed 注解</h3><p>使用@RoleAllowed 注解 和 @Secured 注解 在各个方面基本上都是一直的。唯一显著的区别在于 @RolesAllowed 注解 是 JSR-250 定义的Java 标准注解。 当使用其他框架(非 Spring)时，@RolesAllowed将更会有意义。  </p>
<p>我们先实现配置类  </p>
<pre><code>@Configuration 
@EnableGlobalMethodSecurity(jsr250Enabled=true)  
public class MathodSecurityConfig extends GlobalMethodSecurityConfiguration {

}
</code></pre><ul>
<li>当 jsr250Enabled 属性设置为 true 之后，将会启用一个切点，这样带有 @RolesAllowed 注解的方法都会被 Spring Security 的切面包装起来。  </li>
</ul>
<p>接下来我们就可以使用它  </p>
<pre><code>@RolesAllowed(&quot;ROLE_SPITTER&quot;)
public void addSpittle(Spittle spittle) {

}  
</code></pre><p>无论是 @RolesAllowed 注解还是 @Secured 注解。它们都有一个共同的不足。它们只能根据用户有没有授予特定的权限来限制方法的调用。在判断方法是否执行方面，无法使用其他的因素,接下来我们看一下如何使用 SpEL 与 Spring Security 所提供的方法调用前后注解，实现基于表达式的方法安全性。  </p>
<h2 id="使用表达式实现方法级别的安全性"><a href="#使用表达式实现方法级别的安全性" class="headerlink" title="使用表达式实现方法级别的安全性"></a>使用表达式实现方法级别的安全性</h2><p>Spring Security 3.0 引入了几个新注解，这些注解的值参数中都可以接受一个 SpEL 表达式。表达式可以是任意合法的 SpEL 表达式。如果表达式的计算结果为 true ，那么安全规则通过，否则就会失败。安全规则通过或失败的结果会因为所使用注解的差异而有所不同。   </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7ukukoax2j30xr0fptcx.jpg" data-fancybox="group" data-caption="QQ截图20191011212215.png" class="fancybox"><img alt="QQ截图20191011212215.png" title="QQ截图20191011212215.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7ukukoax2j30xr0fptcx.jpg" class="lazyload"></a>  </p>
<p>同样。我们首先应该实现配置类  </p>
<pre><code>@Configuration  
@EnableGlobalMethodSecurity(prePostEnabled=true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration{

}  
</code></pre><ul>
<li>当prePostEnabled 设置为 true 时 ，它会创建一个切点，这样的话 Spring Security 切面就会包装带有上述4个注解的方法了  </li>
</ul>
<h3 id="表述方法访问规则"><a href="#表述方法访问规则" class="headerlink" title="表述方法访问规则"></a>表述方法访问规则</h3><p>使用以下两个注解    </p>
<ul>
<li><p>@PreAuthorize<br>  表达式会在方法调用之前执行，如果表达式的计算结果不为 true 的话，将会阻止方法执行  </p>
</li>
<li><p>@PostAuthorize<br>  表达式会在方法调用之后执行，如果表达式的计算结果不为 true 的话，将会抛出安全性的异常  </p>
</li>
</ul>
<p>它们两个比 @Secured 和 @RolesAllowed 更灵活 </p>
<ul>
<li><p>@PreAuthorize 使用示例  </p>
<p>  以下是例子，它会检查字数，如果是普通用户那么字数应该在140字以内，如果是付费用户，则不限制字数  </p>
<pre><code>@PreAuthorize( &quot;(hasRole(&apos;ROLE_SPITTER&apos;) and #spittle.text.length()&lt;= 140&gt;)&quot; + &quot;or hasRole(&apos;ROLE_PREMIUM&apos;)&quot;)
public void addSpittle(Spittle spittle) {

}  
</code></pre><p>  表达式中的 #spittle 部分直接引用了方法中的同名参数  </p>
</li>
<li><p>@PostAuthorize </p>
<pre><code>@PostAuthorize(&quot;returnObject.spitter.username == principal.username&quot;)  
public Spittle getSpittleById(long id) {

}
</code></pre><p>  为了遍历的访问受保护方法的返回对象 Spring Security 在 SpEL 中提供了名为 returnObject 的变量。<br>  而 principal 是另一个 Spring Security 内置的特殊名称，它代表了当前认证用户的主要信息</p>
</li>
</ul>
<h3 id="过滤方法的输入与输出"><a href="#过滤方法的输入与输出" class="headerlink" title="过滤方法的输入与输出"></a>过滤方法的输入与输出</h3><p>使用以下两个注解  </p>
<ul>
<li><p>@PreFilter<br>  该注解会过滤传入方法的参数(过滤输入)<br>  下例，能保证方法的列表中只包含当前用户有权限删除的 Spittle</p>
<pre><code>@PreAuthorize( &quot;(hasRole({&apos;ROLE_SPITTER&apos;,&apos;ROLE)ADMIN&apos;})&quot;)
@PreFilter( &quot;hasRole(&apos;ROLE_ADMIN&apos;) || &quot; + &apos;targetObject.spitter.username == principal.name&apos;)
public void deleteSpittle(List&lt;Spittle&gt; spittles) {
    ...
}   
</code></pre><p>  targetObject 是 Spring security 提供的另外一个值，它代表了要进行计算的当前列表元素</p>
</li>
<li><p>@PostFilter<br>  该注解会过滤方法返回的值(过滤输出)  </p>
<pre><code>@PreAuthorize( &quot;(hasRole({&apos;ROLE_SPITTER&apos;,&apos;ROLE)ADMIN&apos;})&quot;)
@PostFilter( &quot;hasRole(&apos;ROLE_ADMIN&apos;) || &quot; + &apos;filterObject.spitter.username == principal.name&apos;)
public List&lt;Spittle&gt; getoffensiveSpittles() {
    ...
}   
</code></pre><p>  FilterObject 是 Spring security 提供的另外一个值，它代表了这个方法所返回的列表中的某一个元素  </p>
</li>
</ul>
<p>上面的两个注释对于安全规则的设置很灵活，但当安全规则的逻辑很复杂时，并不推荐直接写在注释里，一是可读性不好，二是其测试困难，所以此时我们会选择定义许可计算器来解决问题  </p>
<p><strong>定义许可计算器</strong><br>使用 hasPermission()<br>hasPermission() 函数是 Spring Security 为SpEL提供的拓展，它为开发者提供了一个世纪能够在执行计算的时候插入任意的逻辑。我们所需要做的就是编写并注册一个自定义的许可计算器。<br>为此，我们需要实现 Spring Security 的 PermissionEvaluator 接口，该接口需要实现两个不用的 hasPermission() 方法。</p>
<ul>
<li>其中的一个 hasPermission() 方法把要评估的对象作为第二个参数</li>
<li>第二个 hasPermission() 方法在只有目标对象的 ID 可以得到的时候才有用，并将 ID 作为 Serializable 传入第二个参数  </li>
</ul>
<p>下面是一个示例  </p>
<p><a href="http://ww1.sinaimg.cn/large/006buNqily1g7umg8au4gj30mp0mtjy1.jpg" data-fancybox="group" data-caption="QQ截图20191011221747.png" class="fancybox"><img alt="QQ截图20191011221747.png" title="QQ截图20191011221747.png" data-src="http://ww1.sinaimg.cn/large/006buNqily1g7umg8au4gj30mp0mtjy1.jpg" class="lazyload"></a>  </p>
<p>我们就可以使用  </p>
<pre><code>@PreAuthorize(&quot;hasAnyRole({&apos;ROLE_SPITTER&apos;,&apos;ROLE_ADMIN&apos;})&quot;)
@PreFilter(&quot;hasPermission(targetObject,&apos;delete&apos;)&quot;)
public void deleteSpittles(List&lt;Spittle&gt; spittles) { ... }
</code></pre></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">f1rry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/29/保护Web应用/">http://yoursite.com/2019/07/29/保护Web应用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">F1rry's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA    </a><a class="post-meta__tags" href="/tags/Spring/">Spring    </a><a class="post-meta__tags" href="/tags/Spring-Security/">Spring Security    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/01/优先队列/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>优先队列</span></div></a></div><div class="next-post pull_right"><a href="/2019/07/20/AOP/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Spring学习 AOP</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/20/AOP/" title="Spring学习 AOP"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">Spring学习 AOP</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/04/依赖注入DI/" title="Spring学习 依赖注入"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-04</div><div class="relatedPosts_title">Spring学习 依赖注入</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/03/java 散列/" title="JAVA 散列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-03</div><div class="relatedPosts_title">JAVA 散列</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/01/优先队列/" title="优先队列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-01</div><div class="relatedPosts_title">优先队列</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/07/排序/" title="排序算法"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-07</div><div class="relatedPosts_title">排序算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/10/图论算法/" title="图论算法"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-10</div><div class="relatedPosts_title">图论算法</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By f1rry</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>